# 타입스크립트의 타입 시스템

타입스크립트는 자바스크립트로 컴파일하기도 하지만, 가장 중요한 것은 타입 시스템을 제공하는 것.  
2장에서는 이 타입 시스템에 대해 기초부터 알아보도록 하자.

# 편집기를 사용해 타입 시스템 알아보기.

타입스크립트는 타입지정이 되어있지 않으면 타입을 추론한다.  
편집기를 통해 해당 시점에서 무슨 타입으로 판단하고 있는지 확인할 수 있다.

특정 시점에 타입을 어떻게 판단하는지 아는것은 타입 시스템 이해에 큰 도움이 된다.

```ts
function logMessage(message: string | null) {
  if (message) {
    message; // 이 시점에서는 string
  }
}
```

뿐만 아니라 연산자 체인 중간의 타입도 확인할 수 있다.  
편집기는 타입 선언된 곳으로 연결시켜주는 기능을 제공하는데, 이는 오류를 탐지하거나 동작을 이해하는데 큰 도움이 된다.

# 타입이 값들의 집합이라고 생각하기

할당 가능한 값들의 집합이 타입이라 생각하자.  
타입의 범위라 부르기도 한다.

가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, ts 에서는 never 타입에 해당된다.  
그 다음으로 작은 집합은 한가지 값만 포함하는 타입이며, unit 혹은 literal 탕비이라고 한다.

```ts
type A = "A";
type B = "B";
```

여러 타입을 묶으려면 union 타입을 사용한다.

```ts
type AB = "A" | "B";
```

union 타입은 값 또는 타입의 합집합을 의미.

타입스크립트 오류를 보다 보면 '할당 가능한' 이라는 문구를 볼 수 있는데, 이는 집합의 관점에서 원소(값과 타입의 관계에서), 부분 집합(두 타입의 관계)를 의미한다.  
그래서, 타입 체커의 주요 역할 중 하나는 집합이 다른 집합의 부분집합인지 검사하는 것이라고 볼 수 있겠다.

다음처럼 원소를 서술하는 방법도 존재한다.

```ts
interface Identified {
  id: string;
}
```

위의 인터페이스가 타입(Identified) 범위 내의 값들에 대한 설명(타입 명세)이라고 생각해 보자.  
어떤 객체가 string 으로 할당 가능한 id 속성을 가지고 있다면 그 객체는 Identified이다.

구조적 타이핑 규칙에서 말했듯, 어떠한 값이 해당 타입의 속성뿐만 아니라 다른 속성도 가질 수 있음을 의미한다.  
추가 속성을 허용하지 않는 excess property checking개념만 생각하다 보면 놓치기 쉽다.

```ts
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

& 연산자는 두 타입의 intersection(교집합)을 계산한다.  
공통 속성이 없으므로 never타입인가? 라 생각할 수 있으나, 타입 연산자는 인터페이스 속성이 아니라, 값의 집합(타입의 범위)에 적용된다.

그래서, name 속성을 갖는 Person 범위와 birth, death? 속성을 갖는 Lifespan 범위의 교집합은 name, birth, death? 속성을 갖는 범위가 된다.  
Person -> name 속성을 갖는 모든 객체, Lifespan -> birth, death? 속성을 갖는 모든 객체이므로 두 범위의 교집합은 세 속성을 갖는 모든 객체가 되는 것.  
객체를 Person 으로 봐도 문제가 없고, Lifespan으로 봐도 문제가 없어야 한다.  
그러려면 두 타입의 모든 속성을 가져야 하기 때문에 교집합은 모든 속성을 갖는 객체가 된다.

Person 과 Lifespan 을 둘 다 가지는 값은 인터섹션 타입에 속하게 된다.  
동일하게 세 속성 말고 다른 속성을 더 가지는 값도 PersonSpan 타입에 속한다.

두 인터페이스의 union인 | 연산자는 좀 다르게 동작하는데, 아래 예제를 살펴 보자.

```ts
type K = keyof (Person | LifeSpan);
```

K는 never.  
위 코드는 Person 타입 또는 LifeSpan 타입인 타입의 key를 갖고와 리터럴 타입으로 정의하는데, 정리해 보면 다음과 같다.

Person 타입 이거나, LifeSpan 타입이어야 한다.  
그래서, union 연산자를 통해 만들어진 타입(이라고 해 보자)의 속성은 Person 에 있는 속성일수도 있고, LifeSpan에 있는 속성일 수 있다.  
해당 속성들이 확실히 존재한다는 보장을 하지 못하므로 TS는 두 인터페이스에 공통적으로 속한 속성만 인정하는 것이다.  
그래서, 인터페이스에서의 union연산은 공통된 속성만 갖으므로 keyof 연산자를 통하면 never가 된다.

아래 연산자를 잘 이해하면 크게 도움이 될 것이다.

```ts
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

일반적으로 위 Person과 LifeSpan 예제에서는 extends를 사용한다.  
이 extends키워드의 의미는 '할당 가능한' 과 비슷하게, '~의 부분집합'이라는 의미로도 받아들일 수 있다.

```
interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth:Date;
  death?:Date;
}
```

PersonSpan 타입의 모든 값은 string 타입의 name 속성을 가져야 한다.  
그리고 birth 속성을 가져야 제대로 된 부분집합인 PersonSpan이라 할 수 있다.

서브타입은 어떤 집합이 다른 집합의 부분집합이라는 의미가 된다.  
클래스 관점에서는 서브클래스가 된다.

```ts
interface Vector1D { x: number;}
interface Vector2D extends Vector1D { y: number;}
interface Vector3D extedns Vector2D { z: number;}
```

이 관계는 상속관계로 그려지지만, 벤 다이어그램으로 그리는게 더 적절하다.

string 타입의 name을 갖는 객체는 모두 Person 객체이다.  
그 중에서, birth 속성을 갖는 객체는 Person이기도 하며, Person의 부분집합이며, 이를 PersonSpan이라 이름지은 것이다.  
extends 없이도 작성이 가능하지만, 리터럴 타입과 유니온 타입에 대해 생각해 본다면 집합 스타일이 더 직관적이다.

```ts
interface Vector1D {
  x: number;
}
interface Vector2D {
  x: number;
  y: number;
}
interface Vector3D {
  x: number;
  y: number;
  z: number;
}
```

extends 키워드는 제네릭 타입에서 한정자로도 쓰이며, 이 문맥에서는 ~의 부분집합을 의미하기도 한다.

```ts
function getKey<K extends string>(val: any, key: K) {
  // ...
}
```

string을 상속 관점에서 생각하면 이해하기 어렵지만, 부분집합 관점에서 생각하면 이해하기 쉽다.  
K는 string의 부분집합.  
string, 'a', '3' 등 모두 가능해 지는 것.

```ts
getKey({}, "x"); // 'x' 는 string을 상속(부분집합), 오류 없음
getKey({}, Math.random() < 0.5 ? "a" : "b"); // 'a' | 'b' 는 string을 상속(부분집합), 오류 없음
getKey({}, document.title); // string은 string을 상속(부분집합), 오류 없음
getKey({}, 12); // 오류
```

12를 넘겨주면 ~에 할당될 수 없습니다 라는 문구가 출력되는데, 이는 상속의 관점에서 상속할 수 없습니다로 바꿀 수 있고, 상속 관점에서는 ~의 부분집합이 될 수 없습니다. 로 이해 가능하다.  
할당과 상속 관점으로 전환하면 keyof T 를 이해하기 수월해 진다.

```ts
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point; // "x" | "y"

function sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {
  // ...
}

const pts: Point[] = [
  { x: 1, y: 1 },
  { x: 2, y: 0 },
];
sortBy(pts, "x"); // 정상, 'x' 는 'x' | 'y' 를 상속(또는 keyof T('x' | 'y') 의 부분집합).
sortBy(pts, "y"); // 똑같이 정상
sortBy(pts, Math.random() < 0.5 ? "x" : "y"); // 정상 'x' | 'y' 는 'x' | 'y' 를 상속.
sortBy(pts, "z"); // 오류. '"z"' 형식의 인수는 '"x" | "y"'형식의 매개변수에 할당될 수 없습니다.
```

타입들이 엄격한 상속관계가 아니라면 집합 스타일이 더욱 바람직함.  
string | number와 string | Date 사이의 Intersection은 공집합이 아니라 string이며, 서로의 부분집합도 아니다.

위 내용들을 한번 정리해 보자.

타입을 값의 집합으로 생각하면 이해하기 편하다.(타입의 범위)  
이 집합은 유한(boolean, 리터럴) 하거나 무한(string, number)하다.  
타입스크립트의 타입은 엄격한 상속관계가 아니라 겹쳐지는 집합으로 표현된다.  
두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.  
한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.(구조적 타이핑)  
타입 연산은 집합의 범위에 적용된다.  
A와 B의 인터섹션은 A와 B의 범위의 인터섹션, 객체 타입에서는 A & B 인 값이 A 와 B의 속성을 모두 가짐을 의미 (A | B 는 공통적인 속성만 가짐을 의미)  
상속, 할당가능, 서브타입, 부분집합 은 같은 의미.

```ts
interface A {
  common: string;
  a: string;
}

interface B {
  common: string;
  b: string;
}

// keyof (A&B) = (keyof A) | (keyof B)
// 우변 : "common" | "a" 와 "common" | "b" 의 합집합 -> "common" | "a" | "b"
// 좌변 : 집합의 범위에서 생각. A이면서 B이려면 모든 속성을 가져야 함. -> A와 B의 모든 속성을 가짐.

// keyof (A|B) = (keyof A) & (keyof B)
// 우변 : "common" | "a" 와 "common" | "b" 의 교집합 -> "common"
// 좌변 : 집합의 범위에서 생각. A거나 B이면 공통된 속성인 common은 반드시 가짐. 'a'와 'b' 는 있을수도, 없을수도 있음.
// 그래서 엄밀히 말하면 { common: string; a?: string; b?: string; } (+ a또는 b가 반드시 있어야 함) 이 되지만 keyof 결과는 공통 속성인 common만 남게 됨.
```

# 타입 공간과 값 공간의 심벌 구분하기

심벌이 같더라도, 속하는 공간에 따라 다른것을 나타낼 수 있기에, 주의해야 한다.

```ts
interface Cylinder {
  height: number;
  radius: number;
}

const Cylinder = (radius: number, height: number) => ({ radius, height });
```

위 코드에서 interface Cylinder는 Cylinder타입으로 쓰인다.  
const Cylinder는 Cylinder와 이름은 같지만 값으로 쓰이며 아무런 관련도 없다.

값으로 쓰일수도, 타입으로 쓰일수도 있다.

```ts
if (shape instanceof Cylinder) {
  shape.radius; // 에러 발생. '{}' 형식에 'radius' 속성이 없습니다.
}
```

instanceof 는 런타임 연산자이고, 값에 대한 연산을 수행.  
그래서, 타입이 아니라 함수를 참조하게 됨.  
참고로 JS로 컴파일되며 런타임시에는 타입정보가 제거되므로 런타임시 Cylinder 타입에 대한 정보는 없음.

```ts
type T1 = 'string';
type T2 = 123;
const v1 = 'string';
const v2 = 123;

const p:Person = {first: 'Jane', last: 'Jacobs'};
function Person:Person (first: string, last: string);
```

얼핏 보면 구분하기 힘들 수 있기에 주의해야 한다.

Class 와 enum은 상황에 따라 타입과 값 두가지 모두 가능한 예약어다.

```ts
class Cylinder {
  height = 1;
  radius = 1;
}

function test(shape: unknown) {
  if (shape instanceof Cylinder) {
    // interface Cylinder는 에러를 발생시킨다.
    shape.radius;
    shape;
  }
}
```

위 코드에서 Cylinder 클래스는 타입으로 쓰였다.  
클래스가 타입으로 쓰일때는 속성과 메서드가 사용되지만, 값으로 쓰일 때는 생성자가 사용된다.

연산자 중에서도 타입에서 쓰일때와 값에서 쓰일 때가 다른 기능을 하는 것들이 존재하는데, 그 중 하나가 typeof 연산자이다.

```ts
type T1 = typeof P; // 타입에서 쓰임. Person 타입
type T2 = typeof email;
const v1 = typeof p; // 값에서 쓰임. "Object"
const v2 = typeof email; // 값은 "Function"
```

타입의 관점에서, typeof는 타입을 읽어 타입을 반환.  
값의 관점에서, typeof는 JS 런타임의 typeof 연산자가 됨.

대상 심벌의 런타임 타입 문자열을 반환한다.  
런타임 타입이라는 것은 JS의 타입을 의미하며, 타입스크립트의 타입이 무수히 많은것과 대조적으로 string, number, boolean, undefined, object, function 만이 존재한다.

그래서, 클래스에 대한 typeof 는 상황에 따라 다르게 동작하게 되는데, 한번 알아 보자.

```ts
const v = typeof Cylinder; // "function" (클래스가 실제로는 함수로 구현되므로)
type T = typeof Cylinder; // typeof Cylinder 타입
```

v는 이해가 되는데, T는 이해가 잘 가지 않음.  
T 라는 타입은 typeof Cylinder 그 자체가 타입이 됨.

중요한 점은 Cylinder가 인스턴스 타입이 아니라는 것.  
실제로는 new 키워드를 사용했을 때 볼 수 있는 생성자 함수.

```ts
type T = typeof Cylinder;

declare let fn: T;
const c = new fn();
```

c의 타입은 Cylinder.

다음 코드처럼 InstanceType 제너릭을 사용해 생성자 타입과 인스턴스 타입을 전환할 수 있다.

```ts
type C = instanceType<typeof Cylinder>;
```

속성 접근자인 [] 또한 값과 타입으로 사용될 수 있다.

```ts
const first: Person["first"] = p["first"];
```

뿐만 아니라 두 공간 사이에서 다르게 사용되는 경우는 다음과 같다.

- this  
  값으로 쓰이는 this는 자바스크립트의 this 키워드에 해당한다.
  타입으로 쓰이는 this는 다형성 this라 불리는 this의 타입스크립트 타입. 서브클래스의 메서드 체인을 구현할 때 유용하다.

- & 와 |
  값에서 &와 | 는 비트연산 (각 AND 와 OR), 타입에서는 Intersection과 Union

외에도 const, extends 등이 있다.

타입스크립트 코드가 잘 동작하지 않는다면, 타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 존재한다.  
아래 코드를 한번 보자.  
options에 단일 객체를 받는다.

```ts
function email(options: { person: Person; subject: string; body: string }) {
  // ...
}
```

자바스크립트는 객채 내의 각 속성을 로컬 변수로 만들어 주는 구조분해 할당을 사용할 수 있다.

```js
function email({ person, subject, body }) {
  // ...
}
```

그런데, 타입스크립트에서 구조분해 할당을 하면 오류가 발생한다.

```ts
function email({ person: Person, subject: string, body: string }) {
  // ...
}
```

바인딩 요소 '~' 에 암시적으로 'any' 형식이 있습니다.
'string' 식별자가 중복되었습니다.

타입을 지정해준게 아니라, 구조분해할당에서의 변수 생성으로 이해한 것.  
해결하기 위해서는 타입과 값을 구분해야 한다.

```ts
function email({
  person,
  subject,
  body,
}: {
  person: Person;
  subject: string;
  body: string;
}) {
  // ...
}
```

처음에는 혼란스러울 수 있으니 제대로 알고 넘어가도록 하자.

이번 챕터 내용을 요약하면...  
타입과 값을 확실히 구분하자.  
모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.  
type과 interface는 타입 공간에만 존재하는데, 컴파일 후에는 사라진다.  
class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.  
"foo" 는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있다.  
차이점을 알고 구분할 줄 알아야 한다.  
typeof, this, const, extends 등 많은 연산자와 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

# 타입 단언보다는 타입 선언을 사용하기

```ts
interface Person {
  name: string;
}
const alice: Person = { name: "Alice" };
const bob = { name: "Bob" } as Person;
```

얼핏 보면 결과가 같은 것으로 보이지만, 그렇지 않다.  
첫번째 방법은 alice 변수에 타입을 선언해 변수의 값이 선언된 타입임을 명시한다.  
두변째 방법은 타입 단언을 수행하는데, 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.

타입 선언을 사용하는게 낫다.

```ts
const alice: Person = {}; // 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다 라는 에러 발생.
const bob = {} as Person; // 오류가 발생하지 않는다.
```

타입 단언은 강제로 타입을 지정했으므로 속성이 없더라도 Person 타입으로 간주한다.  
bob.name 으로 접근시 오류를 잡아내지 못하고, 런타임시 에러가 발생할 수 있다.

속성을 추가할 때도 마찬가지인데,

```ts
const alice: Person = { name: "Alice", age: 36 };
// 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Person' 형식에 'age'가 없습니다. 라는 오류 발생.

const bob = { name: "Bob", age: 36 } as Person;
// 오류가 없다!
```

타입 선언문에서는 잉여 속성 체크가 동작했지만, 단언문에서는 적용되지 않았다.

화살표 함수 사용시 추론된 타입이 모호할 때가 있다.

```ts
const people = ["alice", "bob", "jan"].map((name) => ({ name }));
```

people 의 타입은

```
{
    name: string;
}[]
```

인데, Person 타입을 사용하고 싶다.  
타입 단언을 사용하면 될까?

```ts
const people = ["alice", "bob", "jan"].map((name) => ({ name } as Person));
```

타입 자체는 Person[] 이 되긴 하나, 위에서 지적된 문제가 그대로 발생한다.

```ts
const people = ["alice", "bob", "jan"].map((name) => ({} as Person));
// 오류 없음
```

가장 직관적인것은 화살표 함수 내부에서 타입을 선언하는 것이다.

```ts
const people = ["alice", "bob", "jan"].map((name) => {
  const person: Person = { name };
  return person;
});
```

간단한 함수였는데, 꽤나 번잡해졌다.  
더 좋은방법은 화살표 함수의 반환 타입을 선언하는 것이다.

```ts
const people = ["alice", "bob", "jan"].map((name): Person => ({ name }));
```

위의 번잡한 코드와 동일한 체크를 수행한다.  
괄호의 위치에 따라 의미가 달라질 수 있음에 주의하자.  
(name): Person => ... 는 반환값이 Person 타입이라는 것이고, (name: Person) => ... 는 name 의 타입이 Person 이라는 것이다.  
최종적으로는 다음과 같은데,

```ts
const people: Person[] = ["alice", "bob", "jan"].map(
  (name): Person => ({ name })
);
```

함수 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 한다.  
그래야 정확한 곳에 오류가 표시된다.

위 내용만 보면 타입 선언만 쓰면 되고 타입 단언은 쓸모가 없어 보인다.  
타입 단언이 필요한 경우를 한번 살펴 보자.

```ts
document.querySelector('#myButton').addEventLister('click', e => {
  e.currentTarget // 타입은 EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button // 타입은 HTMLButtonElement;
}
```

e.currentTarget 이 HTMLButtonElement인지, HTMLDivElement인지 알지 못한다.  
단지 EventTarget 이라고는 알고 있을뿐.

우리는 알고 있기에, 타입을 단언해 사용하자.

as 뿐 아니라 ! 또한 단언문에 될 수 있다.

```ts
document.getElementById("myButton"); // 타입은 HTMLElement | null
document.getElementById("myButton")!; // 타입은 HTMLElement
```

null 이 아님을 단언하는 것.  
null 이 아님을 확신할 때 사용하고, 확실하지 않으면 null check 를 해 주자.

그리고, 타입 단언문을 통해 임의의 타입 간에 변환은 불가능하다.  
A가 B의 부분집합일때, 타입 단언이 가능하다.  
HTMLElement은 HTMLElement | null의 서브타입이고, 변환이 가능하다.  
HTMLButtonElement는 EventTarget의 서브타입이기에 역시 가능하다.  
Person 은 {}의 서브타입이므로 가능하다.

Person 과 HTMLElement는 서로의 서브타입이 아니므로 불가능하다.

```
const body = document.body;
const el = body as unknown as Person; // 오류발생
```

굳이 변환하겠다면 unknown 을 사용해야 한다.  
모든 타입은 unknown의 서브타입이므로 오류없이 변환이 가능해진다.

오류가 없을 뿐이지 위험한 행동임을 유의하자.

그래서...  
타입단언(as)보다는 타입선언(:)을 사용하자.  
화살표 함수의 반환타입 사용에 유의하자.  
타입스크립트보다 타입을 더 잘 알고있는 경우에 타입단언(as나 !)을 사용하자.

# 객체 래퍼 타입 피하기

자바스크립트에는 객체 이외에도 Primitive Type이라는 타입이 존재한다.  
기본형들은 불변이며, 메서드를 가지지 않는다는 점에서 객체와 구분된다.

```js
"primitive".charAt(3);
```

위 코드와 같이 마치 메서드를 갖고 있는 것 처럼 보이는데, charAt은 string의 메서드가 아니다.  
string primitive type에는 메서드가 없지만, 자바스크립트에는 String object type이 존재한다.  
이하에서는 string 을 기본형, String을 String 객체라 하자.  
charAt같은 메서드를 사용할 때, 기본형을 String객체로 래핑하고, 메서드를 호출한 후, 마지막에 래핑한 객체를 버린다.

String.prototype을 몽키패치 해 동작을 한번 보자.

```js
const originalCharAt = String.prototype.charAt;
String.prototype.charAt = function (pos) {
  console.log(this, typeof this, pos);
  originalCharAt.call(this, pos);
};

"test".charAt(3); // String { 'test' } object 3
```

메서드 내의 this는 String 객체 레퍼.  
String객체를 직접 생성할 수 있으며, 마치 string 기본형처럼 동작한다.  
하지만 항상 같게 동작하는 것은 아닌데, 객체다 보니 eqeqeq 연산자 사용시 같은 문자열이라도 같지 않다고 나온다.

```js
let x = "hello";
x.language = "English";
console.log(x.language);
```

오류 없이 undefined가 출력되는데, x가 String 객체로 변환된 후 language 프로퍼티에 값이 할당된 후 버려졌기에 undefined가 출력 된 것이다.

String 뿐 만 아니라, Number, Boolean 등 다양한 객체 래퍼 타입이 존재한다.  
객체 래퍼 타입들 덕분에 기본형 값에 메서드를 사용할 수 있는 것이다.

string 을 사용할 때는 특히 유의해야 한다.  
문제없이 동작하는 경우도 있기 때문이다.

```js
function getStringLen(foo: String) {
  return foo.length;
}

getStringLen("Hello");
getStringLen(new String("Hello"));
```

둘 다 오류가 없다.  
그러나 string을 매개변수로 받는데, String 래퍼 객체를 전달하면 오류가 발생한다.

```js
function isGreeting(phrase: String) {
  return ["hello", "good day"].includes(phrase);
  // 'String' 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다.
  // 'string'은(는) 기본 개체이지만 'String'은(는) 래퍼 개체입니다.
  // 가능한 경우 'string'을(를) 사용하세요.
}
```

일반적으로 래퍼 객체를 직접 생성하는 경우가 거의 없고, 기본형 타입을 객체 래퍼에 할당할 필요도 없기에 그냥 기본형 타입만을 사용하는 것이 낫다.  
new 키워드 없이 Bigint와 Symbol 을 호출하는 경우에는 기본형을 생성하기에 이 경우에는 사용해도 된다.

요약하자면...  
객체 래퍼 타입의 동작 원리에 대해 알아 두자.  
객체 래퍼 타입 사용은 지양하고 기본형 타입을 사용하자.

## 잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴을 할당할 때 해당 타입의 속성이 있는지, 그외 속성은 없는지 확인한다.

```ts
interface Room {
  floor:number;
}

const r: Room = {
  floor: 3;
  size: 72.8;
  // 개체 리터럴은 알려진 속성만 지정할 수 있으며, 'Room' 형식에 'size'이(가) 없습니다.
}
```

구조적 타이핑 관점에서는 오류가 발생하지 않아야 한다.  
임시 변수를 통하는 경우를 살펴보자.

```ts
const obj = {
  floor: 3;
  size: 72.8;
}
const r: Room = obj; // 정상
```

obj 타입은 {floor: number, size:number} 타입으로 추론된다.  
이 Room 타입은 obj타입의 부분집합이 되므로 Room에 할당 가능하며 타입 체커도 통과하게 된다.

두 코드의 차이점이 뭘까?  
위 코드는 잉여 속성 체크가 수행되었고, 아래 코드는 수행되지 않았다.  
할당 가능 검사(구조적 타이핑 관점)와 잉여 속성 체크는 별개의 작업임을 알면 헷갈리지 않는다.

잉여 속성 체크가 왜 필요한걸까?  
다음 코드를 한번 보자.

```ts
interface Options {
  title: string;
  darkMode?: boolean;
}

function createWindow(option: Options) {
  if (options.darkMode) {
    setDarkMode();
  }
  ...
}

createWindow({
  title: 'TODO List',
  darkmode: true
})
```

만약 위 코드가 JS 코드였다면, 아무런 문제 없이 실행되고, setDarkMode는 실행되지 않았을 것이다.

그러나 타입스크립트의 잉여 속성 체크가 동작해 에러를 잡아낸다.  
개체 리터럴은 알려진 속성만 지정할 수 있지만 'Options' 형식에 'darkmode'이(가) 없습니다.  
'darkMode'을(를) 쓰려고 했습니까?  
라는 오류가 출력된다.

순수한 구조적 타입 체커는 이러한 종류의 오류를 잡아내지 못한다.  
string타입의 title, boolean타입의 darkMode 속성을 갖는 모든 객체는 Options타입 집합의 원소이다.  
그래서, 타입은 범위가 매우 넓어질 수 있다.  
심지어는 const o1: Options = document; 도 가능하다. title과 darkMode 속성을 갖으므로..

잉여 속성 체크를 통해 알 수 없는 속성을 허용하지 오류를 미연에 방지한다.  
이를 엄격한 객체 리터럴 체크라고도 한다.

잉여 속성 체크를 원하지 않으면 인덱스 시그니처를 사용해 추가적인 속성을 예상하도록 할 수 있다.

```ts
interface Options {
  darkMode?: boolean;
  [otherOptions: string]: unknown;
}

const o: Options = { darkMode: true, test: "test" };
```

아무런 오류가 없다.  
그러나 잉여 속성 체크를 사용하지 않는게 적절한가? 는 뒤에서 다룬다.

임시 변수나 타입 단언을 사용해 에러를 무력화 시키는 예제가 있는데, 해당 속성이 없으므로 에러가 뜨는 잘못된 내용이므로 오히려 더 헷갈리니 그냥 넘어가자.

선택적 속성만 갖는 경우는 어떻게 될까?

```ts
interface Options {
  darkMode?: boolean;
  width?: number;
  height?: number;
}
const opts = { test: "test" };
const o: Options = opts;
```

임시 변수를 통하므로 잉여 속성 체크가 동작하지 않으므로 오류가 없지 않을까? 싶지만 오류가 발생한다.  
{test: string} 타입과 Options 타입에 공통적인 속성이 있음을 체크하는 별도의 체크를 수행한다.  
공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는 데 효과적이다.  
opts 객체에 선택적인 속성 하나라도 있으면 오류가 사라지게 된다.

여러 체크가 있는데 정리하자면...  
객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.  
잉여 속성 체크는 구조적 할당 가능성 체크(구조적 타입 체커)와 역할이 다르다.  
잉여 속성 체크는 임시 변수를 통하면 체크를 안할 수 있다.  
정리하면 구조적 타입 체크, 잉여 속성 체크, 공통 속성 체크(모든 속성이 선택적인 경우) 3가지의 체크가 존재하니 잘 사용하자.

## 함수 표현식에 타입 적용하기

JS(와 TS)는 함수 표현식과 선언식을 다르게 인식한다.  
함수 표현식을 사용하는 것이 좋은데, 매개변수와 반환값까지 전체를 함수 타입으로 선언해 표현식에 재사용 할 수 있기 때문이다.  
(위와같은 내용 뿐 아니라 표현식은 선언부만 호이스팅되므로 일반적으로 권장되는 방식이다.)

```ts
type GetPopulationFn = (city: string) => number;
const getPopulation: GetPopulationFn = (city) => {
  /* ... */
};
```

city에 타입을 지정해주지 않더라도 string 타입임을 알고 있다.  
이게 왜 장점이 되는지 잘 와닿지 않는다.  
다음 예제를 한번 보자.

```ts
function add(a: number, b: number) {
  return a + b;
}
function sub(a: number, b: number) {
  return a - b;
}
function mul(a: number, b: number) {
  return a * b;
}
function div(a: number, b: number) {
  return a / b;
}

type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
const sub: BinaryFn = (a, b) => a - b;
const mul: BinaryFn = (a, b) => a * b;
const div: BinaryFn = (a, b) => a / b;
```

선언식보다 표현식을 사용한 것이 타입 구문이 적어 간결하고, 구현부도 분리되어 있어 로직이 분명해 진다.

HTTP 요청을 보내는 예제 코드를 한번 보자.

```ts
async function getQuote() {
  const response = await fetch("API EndPoint");
  const quote = await response.json();
  return quote;
}
```

만약 잘못된 EndPoint거나, 네트워크에 문제가 생겨 200 외의 응답이 온 경우, 잘못될 수 있다.  
'404 Not Found' 가 포함된 내용이 JSON이 아닐 수 있는데, 이 때 response.json()은 JSON 형식이 아니라는 새로운 오류 메시지를 담아 거절된 프로미스를 반환한다.  
호출한 곳에서는 JSON이 아니라는 오류를 받아, 실제 오류인 404 Not Found가 감춰진다.  
또한, fetch 실패하면 거절된 프로미스를 응답하지는 않는다는걸 간과하기 쉽다.

상태 체크를 수행해 줄 checkedFetch 를 작성해 보자.

```ts
// lib.dom.d.ts 에 선언된 fetch 타입
declare function fetch(
  input: RequestInfo,
  init?: RequestInit
): Promise<Response>;
```

```ts
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error("Request Failed: " + response.status);
  }
  return response;
}
```

OK 응답이 아닌 경우 json() 호출 이전에 오류를 던져 json 이 아니라는 오류로 인해 숨겨지는 현상을 수정한다.  
이 코드도 잘 동작하지만, 더욱 간결하게 작성할 수 있다.

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error("Request Failed: " + response.status);
  }
  return response;
};
```

선언식을 표현식으로 바꾸었고, 함수 전체에 fetch타입을 적용해 input과 init 타입을 추론할 수 있게 했다.  
타입 구문은 또한 checkFetch의 반환 타입을 fetch의 반환 타입과 같음을 보장한다.  
throw 대신 return 을 사용했을 경우, 타입스크립트는 에러를 발견해낸다.

Type '(input: RequestInfo | URL, init: RequestInit | undefined) => Promise<Response | Error>' is not assignable to type '(input: RequestInfo | URL, init?: RequestInit | undefined) => Promise<Response>'.  
Type 'Promise<Response | Error>' is not assignable to type 'Promise<Response>'.  
Type 'Response | Error' is not assignable to type 'Response'.

이러한 오류는 물론 선언식에서도 발생하는데, 발생 위치가 다르다.  
선언식은 호출한 위치에서, 표현식은 구현부에서 발생한다.

요약하자면 다음과 같다.

1. 매개변수나 반환값에 타입을 직접 명시하기보단 표현식 전체에 타입 구문을 적용하자.
2. 다른 함수의 시그니처(함수 타입)를 참조하려면 typeof fn 과 같이 사용하면 된다.

## 타입과 인터페이스의 차이점 알기

타입스크립트에서 타입을 정의한느 방법은 두가지가 있다.

```ts
type TState = {
  name: string;
  capital: string;
};

interface IState {
  name: string;
  capital: string;
}
```

원시 타입에는 주로 Type을 객체 타입에는 주로 interface 를 사용하라고만 어디선가 들은게 기억나는데 이번 챕터에서 자세히 알아보자.  
(타입을 정의할 때, 인터페이스 대신 클래스를 사용할 수 있지만 클래스는 값으로도 쓰일 수 있는 자바스크립트 런타임 개념이다.)

대부분의 경우 타입과 인터페이스 둘다 사용가능하지만, 차이를 알고 같은 상황에서는 동일한 방법을 사용해 일관성을 유지하는것이 중요하다.  
꼭 타입과 인터페이스 말고도 일관성 유지는 유지보수 관점에서 매우 중요.

잉여 속성 체크, 인덱스 시그니처, 함수 타입, 제네릭 등 다양한 것들이 둘 다 가능하다.  
인터페이스는 타입을 확장할 수 있으며, 타입은 인터페이스를 확장할 수 있다.  
클래스를 구현(implements)할 때도 타입과 인터페이스 둘 다 사용가능하다.

```ts
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number };
```

주의할 점은 인터페이스는 유니온 타입 같은 복잡한 타입을 확장하지는 못한다.  
복잡한 타입을 확장하고 싶다면 타입과 &를 사용하자.

```ts
type Input = {
  /* ... */
};
type Onput = {
  /* ... */
};
interface VariableMap {
  [name: string]: Input | Output;
}

// Input, Output을 하나의 변수명으로 매핑하는 인터페이스
```

유니온 타입에 name 속성을 붙인 타입을 만들 수 있는데,

```ts
type NamedVariable = (Input | Output) & { name: string };
```

이 타입은 인터페이스로 표현이 불가능하다.  
뿐만아니라 type키워드는 유니온이 될 수 있고 매핑된 타입 조건부 타입 같은 고급 기능에 활용되기도 하며 튜플과 배열 타입도 type 키워드를 통해 더 간결하게 표현할 수 있다.  
반면 인터페이스는 보강이 가능하다는 장점이 존재한다.

```ts
interface IState {
  name: string;
  capital: string;
}

interface IState {
  population: number;
}

const kim: IState = {
  name: "test",
  capital: "test",
  population: 30,
};
```

이처럼 속성을 확장하는 것을 선언 병합이라고 한다.  
주로 타입 선언 파일에서 사용되는데 타입 선언 파일을 작성할 때는 선언 병함을 지원하기 위해 반드시 인터페이스를 사용해야 한다.

타입스크립트는 여러 버전의 자바스크립트 표준 라이브러리에서 여러 타입을 모아 병합하게 된다.  
예를 들어 Array 인터페이스는 lib.es5.d.ts 에 정의되어 있고 기본적으로 lib.es5.d.ts 에 선언된 인터페이스가 사용된다.  
tsconfig.json 의 lib 목록에 ES2015를 추가하면 타입스크립트는 lib.es2015.d.ts에 선언된 인터페이스를 병합하는데, 이 때 es2015에서 추가된 find 같은 메서드가 포함되어 사용할 수 있게 한다.  
확장가능하게 하려면 interface를 불가능하게 하려면 type을 사용해야 한다.

그래서 어느 것을 사용해야 하느냐?  
복잡한 타입이면 당연히 type을 사용하자. 인터페이스는 유니온 타입을 확장하지 못한다.  
두가지 방법이 모두 가능하면, 일관성을 유지(타입을 주로 사용하면 타입을, 인터페이스를 주로 사용하면 인터페이스를)하자.  
아직 계획 단계의 프로젝트라면 확장가능성을 고려해 보아야 한다.  
예를 들어, API나 라이브러리에 대한 타입 선언은 버전이 바뀜에 따라 확장될 수 있으므로 interface가 좋다.  
그러나 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계(?)이므로 타입을 사용하자.

## 타입 연산과 제네릭 사용으로 반복 줄이기

같은 코드를 반복하지 말라는 DRY 원칙을 타입에 대해서는 간과했을 수 있다.

```ts
interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate {
  firstName: string;
  lastName: string;
  birthDate: Date;
}

const a: PersonWithBirthDate = {
  firstName: "a",
  lastName: "b",
  birthDate: new Date(),
};
const b: Person = a; // 오류 없음
```

타입 중복은 생각보다 많은 문제를 야기한다.  
선택적 속성 middleName을 Person 에 추가한다고 가정하자.  
그러면 Person 과 PersonWithBirthDate는 완전히 다른 타입이 된다.

타입에서 중복이 흔한 이유는 코드 중복을 줄이는 메커니즘이, 타입에서는 익숙하지 않기 때문이다.  
여러 메커니즘을 살펴보고, DRY 원칙을 타입에서도 지킬 수 있도록 하자.

반복을 줄이는 가장 간단한 방법은 타입에 이름을 붙이는 것.

```ts
function distance(a: { x: number; y: number }, b: { x: number; y: number }) {
  // ...
}
```

위 코드를 다음과 같이 바꿀 수 있다.

```ts
interface Point2D {
  x: number;
  y: number;
}
function distance(a: Point2D, b: Point2D) {
  // ...
}
```

이는 단순히 매개변수 타입뿐 아니라 함수 타입에도 적용된다.  
같은 타입 시그니처를 공유하는 예제를 한번 보자.

```ts
function get(url: string, opts: Options): Promise<Response> {
  /* ... */
}
function post(url: string, opts: Options): Promise<Response> {
  /* ... */
}
```

해당 타입 시그니처를 명명된 타입(Named Type, 타입 정의를 그냥 이렇게 부름)으로 분리해 내자.  
타입 선언(:Type)과 타입 정의(type TypeName) 용어에 주의하자.

```ts
type HTTPFunction = (url: string, opts: Options) => Promise<Response>;
const get: HTTPFunction = (url, opts) => {
  /* ... */
};
const post: HTTPFunction = (url, opts) => {
  /* ... */
};
```

extends 를 통한 확장 또한 중복을 줄이는 방법 중 하나다.

```ts
interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate extends Person {
  birthDate: Date;
}
```

이미 존재하는 타입을 확장하는 경우 일반적이지는 않지만 & 를 사용할 때도 있다.

```ts
type PersonWithBirthDate = Person & { birthDate: Date };
```

이 기법은 유니온 타입(확장이 불가능한)에 속성을 추가하려고 할 때 유용하다.

확장을 하는 개념에서 벗어나, 타입의 일부만 이용하려고 하는 경우도 존재한다.

```ts
interface State {
  usderId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

interface NavState {
  userId: string;
  pageTitle: string;
}
```

이러한 경우에는 State가 NavState를 확장하는 개념이 아니라, State의 부분집합으로 NavState를 정의하는것이 바람직하다.  
State 인덱싱을 통해 가능한데, 한번 보자.

```ts
interface NavState {
  userId: State["userId"];
  pageTitle: State["pageTitle"];
}
```

State내의 타입이 바뀌면, NavState의 타입도 같이 변하게 된다.  
그러나 아직 중복이 존재하는데, 이는 매핑된 타입을 이용하면 좀 더 나아진다.

```ts
interface NavState {
  [(k in "userId") | "pageTitle"]: State[k];
}
```

매핑된 타입은 배열의 필드를 도는 것과 같은 방식인데, 이는 표준 라이브러리에서도 일반적으로 찾을 수 있으며 Pick이라 한다.

```ts
type Pick<T, K> = { [k in K]: T[k] };
```

정의가 완전하진 않지만 다음과 같이 사용할 수 있다.

```ts
type NavState = Pick<State, "userId" | "pageTitle">;
```

마치 함수에서 두개의 매개변수 값을 받아서 결괏값을 반환하는 것처럼, Pick은 T와 K 두 가지 타입을 받아 결과 타입을 반환한다.

태그된 유니온에서도 다른 형태의 중복이 발생할 수 있다.

```ts
interface SavaAction {
  type: "save";
  // ...
}

interface LoadAction {
  type: "load";
  // ...
}

type Action = SaveAction | LoadAction;
type ActionType = "save" | "load";
```

Action 유니온을 인덱싱하면 타입 반복 없이 ActionType을 정의할 수 있다.

```ts
type ActionType = Action["type"]; // 타입은 "save" | "load"
```

Action 유니온에 타입을 더 추가하면, ActionType은 자동적으로 그 타입을 포함한다.  
ActionType은 Pick을 사용해 얻게 되는, type 속성을 가지는 인터페이스와는 다르다.

```ts
type ActionRec = Pick<Action, "type">;
```

결과는 어떨 것 같은가?  
ActionRec는 { type: "save" | "load" }로, "save" | "load" 와는 다름을 유의하자.

한번 생성된 후 업데이트가 일어나는 다음 예제를 한번 보자.

```ts
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}

interface UpdateOptions {
  width?: number;
  height?: number;
  color?: string;
  label?: string;
}

class UIWidget {
  constructor(init: Options) {
    /* ... */
  }
  update(options: UpdateOptions) {
    /* ... */
  }
}
```

이런 경우는 어떻게 중복을 줄일 수 있을까?  
매핑된 타입과 keyof, 인덱싱을 사용하면 된다.

```ts
type UpdateOptions = { [k in keyof Options]?: Options[k] };
```

keyof 는 타입을 받아서 타입 속성의 유니온을 반환한다.

```ts
type OptionsKeys = keyof Options;
// 타입은 "width" | "height" | "color" | "label"
```

매핑된 타입 내부에서 속성을 순회하며 ?와 인덱싱의 조합으로 해당 속성을 선택적으로 만들어 낸다.  
이러한 패턴 역시 널리 알려져 있으며, 표준 라이브러리에 Partial 이라는 이름으로 포함되어져 있다.

```ts
type Partial<T> = {
  [k in keyof T]?: T[k];
};

class UIWidget {
  constructor(init: Options) {
    /* ... */
  }
  update(options: Partial<Options>) {
    /* ... */
  }
}
```

값 형태의 타입을 정의하고 싶을 때도 있다.

```ts
const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: "#00FF00",
  label: "VGA",
};
```

이럴 경우 typeof 를 사용하면 된다.

```ts
type Options = typeof INIT_OPTIONS;
```

속성의 타입을 추론해서, 새로운 타입을 정의해 준다.  
자바스크립트의 런타임 연산자 typeof 를 사용한 것 처럼 보이지만, 타입스크립트 단계에서 연산되며, 훨씬 더 정확하게 타입을 표현한다.  
값으로부터 타입을 만들어 낼 때는 선언의 순서에 주의해야 한다.  
타입의 정의를 먼저 하고, 그 타입에 할당이 가능하다고 선언하는것이 좋다.

함수나 메서드의 반환 값에 명명된 타입을 만들고 싶을 수 있다.

```ts
function getUserInfo(userId: string) {
  // ...
  return {
    userId,
    name,
    age,
  };
}
// 추론된 반환 타입은 {userId: string; name: string; age: string;}
```

이때는 조건부 타입(뒤에서 다룬다.)이 필요하다.  
앞에서 살펴본 것 처럼 표준 라이브러리에 이러한 패턴이 정의되어 있는데, ReturnType 제너릭이 해당된다.

```ts
type UserInfo = ReturnType<typeof getUserInfo>;
```

typeof getUserInfo 는 다음과 같다.

(userId: string) => {
userId: string;
name: string;
age: number;
}

ReturnType 제네릭은 함수 타입에서 반환값의 타입만 추출하는 역할을 한다.  
제네릭은 타입을 위한 일종의 함수와 같다고 생각하면 쉬울 것이다.

제네릭 타입에서의 매개변수 제한하는 것은 extends를 통해 할 수 있다.

```ts
interface Name {
  first: string;
  last: string;
}

type Duo<T> = [T, T];
```

위와 같이 Duo 타입을 정의하면, 아무 타입이나 올 수 있다.  
extends 키워드를 통해 매개변수가 특정 타입을 확장한다고 선언이 가능해 진다.

```ts
type Duo<T extends Name> = [T, T];
```

이제 Duo 는 Name을 확장하는 타입만 올 수 있기에, first와 last 속성이 존재하는 타입만 올 수 있다.

```ts
const c1: Duo<{ last: string; age: number }> = [
  { last: "Kim", age: 10 },
  { last: "Kim", age: 10 },
];
```

Type '{ last: string; age: number; }' does not satisfy the constraint 'Name'.  
 Property 'first' is missing in type '{ last: string; age: number; }' but required in type 'Name'.(2344)

해당 타입이 Name 조건에 부합하고, 특히 first 속성이 해당 타입에 없지만 Name에는 요구된다고 알려주고 있다.

그래서, 사실 앞에 나온 Pick 의 정의는 미완성이었다.

```ts
type Pick<T, K> = {
  [k in K]: T[k];
};
```

K는 T타입과 무관하고, 범위가 너무 넓다.  
A에 first속성이 들어있고, B에 last속성이 들어있다고 해 보자.  
그러면 A['last'] 로 접근되고, 당연히 오류가 발생한다.

그래서 K는 T의 부분집합, 즉 keyof T가 되어야 한다.

```ts
type Pick<T, K extends keyof T> = {
  [k in K]: T[k];
};
```

```ts
type MyPick<T, K extends keyof T> = {
  [k in K]: T[k];
};

type firstLast = MyPick<Name, "first" | "last">;
type firstMiddle = MyPick<Name, "first" | "middle">; // Name을 확장하지 않고 있으므로 오류 발생.
```

그래서, Pick 의 역할은 해당 타입에서 부분적인 속성 타입(부분 집합의 일부)을 추출하는 것으로, 타입을 확장한다는 관점과는 다르기에, 축소라는 관점에서 타입을 정의한다고 이해하자.

```ts
type FirstOnly = MyPick<Name, "first">;
```

이렇게 하는것이 용도에 알맞다.

그래서, 요약하자면...  
DRY 원칙을 타입에서도 적용해 아름답게 코딩하자.  
keyof, typeof, 인덱싱, 맵핑된 타입, extends를 통해 중복을 피하는 여러 메커니즘들을 알아두고 필요할 때 써먹자.  
제네릭 타입은 타입을 위한 함수와 같다.  
제네릭 타입을 제한하려면 extends를 사용하면 된다.  
표준 라이브러리에 정의된 Pick, Partial, ReturnType을 알아봤고, 이것들에 대해 익숙해 지자.

## 동적 데이터에 인덱스 시그니처 사용하기

타입스크립트에서는 타입에 인덱스 시그니처를 사용해 유연하게 매핑을 표현할 수 있다.

```ts
type Rocket = { [key: string]: string };
const rocket: Rocket = {
  name: "Falcon 9",
  thrust: "4,940 kN",
};
```

```ts
[key: string]: string
```

이 바로 인덱스 시그니처인데, 다음과 같은 의미를 지닌다.  
키 이름: 키의 위치만 표시, 타입 체커에서는 사용하지 않음.  
키 의 타입: string, number, symbol의 조합이어야 하지만 보통은 string 사용.  
값의 타입: 어느것이든 될 수 있다.

그러나 인덱스 시그니처를 사용하면 다음과 같은 단점이 존재한다.

잘못된 키를 포함해 모든 키를 허용한다.  
name 대신 Name, NaMe 등 모두 Rocket 타입이 될 수 있다.  
특정 키가 필요하지 않으며, {} 또한 Rocket 이 될 수 있다.  
키마다 다른 타입을 가질 수 없다.  
thrust 는 number여야 할 수 있다.  
자동완성 기능이나 잉여속성 체크 등 다양한 서비스를 이용할 수 없다.

그러면 인덱스 시그니처는 대체 언제 쓸까?  
동적 데이터를 표현할 때 사용한다.

```ts
function parseCSV(input: string): { [columnName: string]: string }[] {
  // readCSV and return some object
}
```

csv를 파싱할 때, columnName이 키가 되는데 이 값이 파일에 따라 변할 수 있다. 이럴 때 사용한다.  
선언해 둔 열들이 런타임에 실제로 일치한다는 보장이 없다.

걱정된다면 값 타입에 undefined를 추가하면 된다.

```ts
{[columnName: string]: string | undefined}
```

모든 열(속성)에 대해 undefined인지 검사하는 null check가 이루어져야 한다.  
어떤 타입에 가능한 필드가 제한되어 있는 경우라면 인덱스 시그니처로 모델링하면 안된다.  
선택적 타입 또는 유니온 타입으로 모델링하자.

키의 타입인 string이 너무 광범위하다.  
Record 를 사용해 볼 수 있다.

```ts
type Vec3D = Record<"x" | "y" | "z", number>;
```

두번째는 매핑된 타입을 사용해 볼 수 있다.

```ts
type Vec3D = { [k in "x" | "y" | "z"]: k extends "b" ? string : number };
```

이렇게 조건부 타입도 사용할 수 있다.  
조건부 타입은 뒤에서 다룬다.

요약  
런타임때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용하도록 하자.  
안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는것을 고려해보자.  
가능하다면 정확한 타입을 사용하는게 좋다.
