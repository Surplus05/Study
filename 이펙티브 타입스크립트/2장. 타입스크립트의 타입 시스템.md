# 타입스크립트의 타입 시스템  

타입스크립트는 자바스크립트로 컴파일하기도 하지만, 가장 중요한 것은 타입 시스템을 제공하는 것.  
2장에서는 이 타입 시스템에 대해 기초부터 알아보도록 하자.  

# 편집기를 사용해 타입 시스템 알아보기.  
타입스크립트는 타입지정이 되어있지 않으면 타입을 추론한다.  
편집기를 통해 해당 시점에서 무슨 타입으로 판단하고 있는지 확인할 수 있다.  

특정 시점에 타입을 어떻게 판단하는지 아는것은 타입 시스템 이해에 큰 도움이 된다.  

```ts
function logMessage(message: string | null) {
  if(message) {
    message // 이 시점에서는 string
  }

}

```

뿐만 아니라 연산자 체인 중간의 타입도 확인할 수 있다.  
편집기는 타입 선언된 곳으로 연결시켜주는 기능을 제공하는데, 이는 오류를 탐지하거나 동작을 이해하는데 큰 도움이 된다.  

# 타입이 값들의 집합이라고 생각하기  

할당 가능한 값들의 집합이 타입이라 생각하자.  
타입의 범위라 부르기도 한다.  

가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, ts 에서는 never 타입에 해당된다.  
그 다음으로 작은 집합은 한가지 값만 포함하는 타입이며, unit 혹은 literal 탕비이라고 한다.  

```ts
type A = 'A';
type B = 'B';
```

여러 타입을 묶으려면 union 타입을 사용한다.  

```ts
type AB = 'A' | 'B';
```
union 타입은 값 또는 타입의 합집합을 의미.  

타입스크립트 오류를 보다 보면 '할당 가능한' 이라는 문구를 볼 수 있는데, 이는 집합의 관점에서 원소(값과 타입의 관계에서), 부분 집합(두 타입의 관계)를 의미한다.  
그래서, 타입 체커의 주요 역할 중 하나는 집합이 다른 집합의 부분집합인지 검사하는 것이라고 볼 수 있겠다.  

다음처럼 원소를 서술하는 방법도 존재한다.  

```ts
interface Identified {
  id: string;
}
```
위의 인터페이스가 타입(Identified) 범위 내의 값들에 대한 설명(타입 명세)이라고 생각해 보자.  
어떤 객체가 string 으로 할당 가능한 id 속성을 가지고 있다면 그 객체는 Identified이다.  

구조적 타이핑 규칙에서 말했듯, 어떠한 값이 해당 타입의 속성뿐만 아니라 다른 속성도 가질 수 있음을 의미한다.  
추가 속성을 허용하지 않는 excess property checking개념만 생각하다 보면 놓치기 쉽다.  

```ts
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

& 연산자는 두 타입의 intersection(교집합)을 계산한다.  
공통 속성이 없으므로 never타입인가? 라 생각할 수 있으나, 타입 연산자는 인터페이스 속성이 아니라, 값의 집합(타입의 범위)에 적용된다.  

그래서, name 속성을 갖는 Person 범위와 birth, death? 속성을 갖는 Lifespan 범위의 교집합은 name, birth, death? 속성을 갖는 범위가 된다.  
Person -> name 속성을 갖는 모든 객체, Lifespan -> birth, death? 속성을 갖는 모든 객체이므로 두 범위의 교집합은 세 속성을 갖는 모든 객체가 되는 것.  
객체를 Person 으로 봐도 문제가 없고, Lifespan으로 봐도 문제가 없어야 한다.  
그러려면 두 타입의 모든 속성을 가져야 하기 때문에 교집합은 모든 속성을 갖는 객체가 된다.  

Person 과 Lifespan 을 둘 다 가지는 값은 인터섹션 타입에 속하게 된다.  
동일하게 세 속성 말고 다른 속성을 더 가지는 값도 PersonSpan 타입에 속한다.

두 인터페이스의 union인 | 연산자는 좀 다르게 동작하는데, 아래 예제를 살펴 보자.  
```ts
type K = keyof (Person | LifeSpan);
```

K는 never.  
위 코드는 Person 타입 또는 LifeSpan 타입인 타입의 key를 갖고와 리터럴 타입으로 정의하는데, 정리해 보면 다음과 같다.  

Person 타입 이거나, LifeSpan 타입이어야 한다.  
그래서, union 연산자를 통해 만들어진 타입(이라고 해 보자)의 속성은 Person 에 있는 속성일수도 있고, LifeSpan에 있는 속성일 수 있다.  
해당 속성들이 확실히 존재한다는 보장을 하지 못하므로 TS는 두 인터페이스에 공통적으로 속한 속성만 인정하는 것이다.  
그래서, 인터페이스에서의 union연산은 공통된 속성만 갖으므로 keyof 연산자를 통하면 never가 된다.  

아래 연산자를 잘 이해하면 크게 도움이 될 것이다.  
```ts
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

일반적으로 위 Person과 LifeSpan 예제에서는 extends를 사용한다.  
이 extends키워드의 의미는 '할당 가능한' 과 비슷하게, '~의 부분집합'이라는 의미로도 받아들일 수 있다.  

```
interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth:Date;
  death?:Date;
}
```

PersonSpan 타입의 모든 값은 string 타입의 name 속성을 가져야 한다.  
그리고 birth 속성을 가져야 제대로 된 부분집합인 PersonSpan이라 할 수 있다.  

서브타입은 어떤 집합이 다른 집합의 부분집합이라는 의미가 된다.  
클래스 관점에서는 서브클래스가 된다.  

```
interface Vector1D { x: number;}
interface Vector2D extends Vector1D { y: number;}
interface Vector3D extedns Vector2D { z: number;}
```

이 관계는 상속관계로 그려지지만, 벤 다이어그램으로 그리는게 더 적절하다.  

string 타입의 name을 갖는 객체는 모두 Person 객체이다.  
그 중에서, birth 속성을 갖는 객체는 Person이기도 하며, Person의 부분집합이며, 이를 PersonSpan이라 이름지은 것이다.  
extends 없이도 작성이 가능하지만, 리터럴 타입과 유니온 타입에 대해 생각해 본다면 집합 스타일이 더 직관적이다.  

```
interface Vector1D { x: number;}
interface Vector2D { x: number; y: number;}
interface Vector3D { x: number; y: number; z: number;}
```

extends 키워드는 제네릭 타입에서 한정자로도 쓰이며, 이 문맥에서는 ~의 부분집합을 의미하기도 한다.  

```ts

function getKey<K extends string>(val:any, key: K) {
  // ...
}

```

string을 상속 관점에서 생각하면 이해하기 어렵지만, 부분집합 관점에서 생각하면 이해하기 쉽다.  
K는 string의 부분집합.  
string, 'a', '3' 등 모두 가능해 지는 것.  

``` ts
getKey({}, 'x'); // 'x' 는 string을 상속(부분집합), 오류 없음
getKey({}, Math.random() < 0.5 ? 'a' : 'b'); // 'a' | 'b' 는 string을 상속(부분집합), 오류 없음
getKey({}, document.title); // string은 string을 상속(부분집합), 오류 없음
getKey({}, 12); // 오류
```

12를 넘겨주면 ~에 할당될 수 없습니다 라는 문구가 출력되는데, 이는 상속의 관점에서 상속할 수 없습니다로 바꿀 수 있고, 상속 관점에서는 ~의 부분집합이 될 수 없습니다. 로 이해 가능하다.  
할당과 상속 관점으로 전환하면 keyof T 를 이해하기 수월해 진다.  

```ts
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point // "x" | "y"

function sortBy<K extends keyof T, T>(vals: T[], key: K):T[] {
  // ...
}

const pts: Point[] = [{x: 1, y: 1} , {x: 2, y: 0}];
sortBy(pts, 'x'); // 정상, 'x' 는 'x' | 'y' 를 상속(또는 keyof T('x' | 'y') 의 부분집합).
sortBy(pts, 'y'); // 똑같이 정상
sortBy(pts, Math.random() < 0.5 ? 'x' : 'y'); // 정상 'x' | 'y' 는 'x' | 'y' 를 상속.
sortBy(pts, 'z'); // 오류. '"z"' 형식의 인수는 '"x" | "y"'형식의 매개변수에 할당될 수 없습니다.
```

타입들이 엄격한 상속관계가 아니라면 집합 스타일이 더욱 바람직함.  
string | number와 string | Date 사이의 Intersection은 공집합이 아니라 string이며, 서로의 부분집합도 아니다.  

위 내용들을 한번 정리해 보자.  

타입을 값의 집합으로 생각하면 이해하기 편하다.(타입의 범위)  
이 집합은 유한(boolean, 리터럴) 하거나 무한(string, number)하다.  
타입스크립트의 타입은 엄격한 상속관계가 아니라 겹쳐지는 집합으로 표현된다.  
두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.  
한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.(구조적 타이핑)  
타입 연산은 집합의 범위에 적용된다.  
A와 B의 인터섹션은 A와 B의 범위의 인터섹션, 객체 타입에서는 A & B 인 값이 A 와 B의 속성을 모두 가짐을 의미 (A | B 는 공통적인 속성만 가짐을 의미)  
상속, 할당가능, 서브타입, 부분집합 은 같은 의미.

```ts
interface A {
  common: string;
  a: string;  
}

interface B {
  common: string;
  b: string;
}

keyof (A&B) = (keyof A) | (keyof B)
// 우변 : "common" | "a" 와 "common" | "b" 의 합집합 -> "common" | "a" | "b"
// 좌변 : 집합의 범위에서 생각. A이면서 B이려면 모든 속성을 가져야 함. -> A와 B의 모든 속성을 가짐.

keyof (A|B) = (keyof A) & (keyof B)
// 우변 : "common" | "a" 와 "common" | "b" 의 교집합 -> "common"
// 좌변 : 집합의 범위에서 생각. A거나 B이면 확실한 속성은 common, 'a'와 'b' 는 있을수도, 없을수도 있기에 제외 -> "common"
```
