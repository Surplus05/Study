# 타입스크립트의 타입 시스템  

타입스크립트는 자바스크립트로 컴파일하기도 하지만, 가장 중요한 것은 타입 시스템을 제공하는 것.  
2장에서는 이 타입 시스템에 대해 기초부터 알아보도록 하자.  

# 편집기를 사용해 타입 시스템 알아보기.  
타입스크립트는 타입지정이 되어있지 않으면 타입을 추론한다.  
편집기를 통해 해당 시점에서 무슨 타입으로 판단하고 있는지 확인할 수 있다.  

특정 시점에 타입을 어떻게 판단하는지 아는것은 타입 시스템 이해에 큰 도움이 된다.  

```ts
function logMessage(message: string | null) {
  if(message) {
    message // 이 시점에서는 string
  }

}

```

뿐만 아니라 연산자 체인 중간의 타입도 확인할 수 있다.  
편집기는 타입 선언된 곳으로 연결시켜주는 기능을 제공하는데, 이는 오류를 탐지하거나 동작을 이해하는데 큰 도움이 된다.  

# 타입이 값들의 집합이라고 생각하기  

할당 가능한 값들의 집합이 타입이라 생각하자.  
타입의 범위라 부르기도 한다.  

가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, ts 에서는 never 타입에 해당된다.  
그 다음으로 작은 집합은 한가지 값만 포함하는 타입이며, unit 혹은 literal 탕비이라고 한다.  

```ts
type A = 'A';
type B = 'B';
```

여러 타입을 묶으려면 union 타입을 사용한다.  

```ts
type AB = 'A' | 'B';
```
union 타입은 값 또는 타입의 합집합을 의미.  

타입스크립트 오류를 보다 보면 '할당 가능한' 이라는 문구를 볼 수 있는데, 이는 집합의 관점에서 원소(값과 타입의 관계에서), 부분 집합(두 타입의 관계)를 의미한다.  
그래서, 타입 체커의 주요 역할 중 하나는 집합이 다른 집합의 부분집합인지 검사하는 것이라고 볼 수 있겠다.  

다음처럼 원소를 서술하는 방법도 존재한다.  

```ts
interface Identified {
  id: string;
}
```
위의 인터페이스가 타입(Identified) 범위 내의 값들에 대한 설명(타입 명세)이라고 생각해 보자.  
어떤 객체가 string 으로 할당 가능한 id 속성을 가지고 있다면 그 객체는 Identified이다.  

구조적 타이핑 규칙에서 말했듯, 어떠한 값이 해당 타입의 속성뿐만 아니라 다른 속성도 가질 수 있음을 의미한다.  
추가 속성을 허용하지 않는 excess property checking개념만 생각하다 보면 놓치기 쉽다.  

```ts
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

& 연산자는 두 타입의 intersection(교집합)을 계산한다.  
공통 속성이 없으므로 never타입인가? 라 생각할 수 있으나, 타입 연산자는 인터페이스 속성이 아니라, 값의 집합(타입의 범위)에 적용된다.  

그래서, name 속성을 갖는 Person 범위와 birth, death? 속성을 갖는 Lifespan 범위의 교집합은 name, birth, death? 속성을 갖는 범위가 된다.  
Person -> name 속성을 갖는 모든 객체, Lifespan -> birth, death? 속성을 갖는 모든 객체이므로 두 범위의 교집합은 세 속성을 갖는 모든 객체가 되는 것.  
객체를 Person 으로 봐도 문제가 없고, Lifespan으로 봐도 문제가 없어야 한다.  
그러려면 두 타입의 모든 속성을 가져야 하기 때문에 교집합은 모든 속성을 갖는 객체가 된다.  

Person 과 Lifespan 을 둘 다 가지는 값은 인터섹션 타입에 속하게 된다.  
동일하게 세 속성 말고 다른 속성을 더 가지는 값도 PersonSpan 타입에 속한다.

두 인터페이스의 union인 | 연산자는 좀 다르게 동작하는데, 아래 예제를 살펴 보자.  
```ts
type K = keyof (Person | LifeSpan);
```

K는 never.  
위 코드는 Person 타입 또는 LifeSpan 타입인 타입의 key를 갖고와 리터럴 타입으로 정의하는데, 정리해 보면 다음과 같다.  

Person 타입 이거나, LifeSpan 타입이어야 한다.  
그래서, union 연산자를 통해 만들어진 타입(이라고 해 보자)의 속성은 Person 에 있는 속성일수도 있고, LifeSpan에 있는 속성일 수 있다.  
해당 속성들이 확실히 존재한다는 보장을 하지 못하므로 TS는 두 인터페이스에 공통적으로 속한 속성만 인정하는 것이다.  
그래서, 인터페이스에서의 union연산은 공통된 속성만 갖으므로 keyof 연산자를 통하면 never가 된다.  

아래 연산자를 잘 이해하면 크게 도움이 될 것이다.  
```ts
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

일반적으로 위 Person과 LifeSpan 예제에서는 extends를 사용한다.  
이 extends키워드의 의미는 '할당 가능한' 과 비슷하게, '~의 부분집합'이라는 의미로도 받아들일 수 있다.  

```
interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth:Date;
  death?:Date;
}
```

PersonSpan 타입의 모든 값은 string 타입의 name 속성을 가져야 한다.  
그리고 birth 속성을 가져야 제대로 된 부분집합인 PersonSpan이라 할 수 있다.  

서브타입은 어떤 집합이 다른 집합의 부분집합이라는 의미가 된다.  
클래스 관점에서는 서브클래스가 된다.  

```ts
interface Vector1D { x: number;}
interface Vector2D extends Vector1D { y: number;}
interface Vector3D extedns Vector2D { z: number;}
```

이 관계는 상속관계로 그려지지만, 벤 다이어그램으로 그리는게 더 적절하다.  

string 타입의 name을 갖는 객체는 모두 Person 객체이다.  
그 중에서, birth 속성을 갖는 객체는 Person이기도 하며, Person의 부분집합이며, 이를 PersonSpan이라 이름지은 것이다.  
extends 없이도 작성이 가능하지만, 리터럴 타입과 유니온 타입에 대해 생각해 본다면 집합 스타일이 더 직관적이다.  

```ts
interface Vector1D { x: number;}
interface Vector2D { x: number; y: number;}
interface Vector3D { x: number; y: number; z: number;}
```

extends 키워드는 제네릭 타입에서 한정자로도 쓰이며, 이 문맥에서는 ~의 부분집합을 의미하기도 한다.  

```ts

function getKey<K extends string>(val:any, key: K) {
  // ...
}

```

string을 상속 관점에서 생각하면 이해하기 어렵지만, 부분집합 관점에서 생각하면 이해하기 쉽다.  
K는 string의 부분집합.  
string, 'a', '3' 등 모두 가능해 지는 것.  

``` ts
getKey({}, 'x'); // 'x' 는 string을 상속(부분집합), 오류 없음
getKey({}, Math.random() < 0.5 ? 'a' : 'b'); // 'a' | 'b' 는 string을 상속(부분집합), 오류 없음
getKey({}, document.title); // string은 string을 상속(부분집합), 오류 없음
getKey({}, 12); // 오류
```

12를 넘겨주면 ~에 할당될 수 없습니다 라는 문구가 출력되는데, 이는 상속의 관점에서 상속할 수 없습니다로 바꿀 수 있고, 상속 관점에서는 ~의 부분집합이 될 수 없습니다. 로 이해 가능하다.  
할당과 상속 관점으로 전환하면 keyof T 를 이해하기 수월해 진다.  

```ts
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point // "x" | "y"

function sortBy<K extends keyof T, T>(vals: T[], key: K):T[] {
  // ...
}

const pts: Point[] = [{x: 1, y: 1} , {x: 2, y: 0}];
sortBy(pts, 'x'); // 정상, 'x' 는 'x' | 'y' 를 상속(또는 keyof T('x' | 'y') 의 부분집합).
sortBy(pts, 'y'); // 똑같이 정상
sortBy(pts, Math.random() < 0.5 ? 'x' : 'y'); // 정상 'x' | 'y' 는 'x' | 'y' 를 상속.
sortBy(pts, 'z'); // 오류. '"z"' 형식의 인수는 '"x" | "y"'형식의 매개변수에 할당될 수 없습니다.
```

타입들이 엄격한 상속관계가 아니라면 집합 스타일이 더욱 바람직함.  
string | number와 string | Date 사이의 Intersection은 공집합이 아니라 string이며, 서로의 부분집합도 아니다.  

위 내용들을 한번 정리해 보자.  

타입을 값의 집합으로 생각하면 이해하기 편하다.(타입의 범위)  
이 집합은 유한(boolean, 리터럴) 하거나 무한(string, number)하다.  
타입스크립트의 타입은 엄격한 상속관계가 아니라 겹쳐지는 집합으로 표현된다.  
두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.  
한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.(구조적 타이핑)  
타입 연산은 집합의 범위에 적용된다.  
A와 B의 인터섹션은 A와 B의 범위의 인터섹션, 객체 타입에서는 A & B 인 값이 A 와 B의 속성을 모두 가짐을 의미 (A | B 는 공통적인 속성만 가짐을 의미)  
상속, 할당가능, 서브타입, 부분집합 은 같은 의미.

```ts
interface A {
  common: string;
  a: string;  
}

interface B {
  common: string;
  b: string;
}

keyof (A&B) = (keyof A) | (keyof B)
// 우변 : "common" | "a" 와 "common" | "b" 의 합집합 -> "common" | "a" | "b"
// 좌변 : 집합의 범위에서 생각. A이면서 B이려면 모든 속성을 가져야 함. -> A와 B의 모든 속성을 가짐.

keyof (A|B) = (keyof A) & (keyof B)
// 우변 : "common" | "a" 와 "common" | "b" 의 교집합 -> "common"
// 좌변 : 집합의 범위에서 생각. A거나 B이면 확실한 속성은 common, 'a'와 'b' 는 있을수도, 없을수도 있기에 제외 -> "common"
```

# 타입 공간과 값 공간의 심벌 구분하기  
심벌이 같더라도, 속하는 공간에 따라 다른것을 나타낼 수 있기에, 주의해야 한다.  

```ts
interface Cylinder {
  height: number;
  radius: number;
}

const Cylinder = (radius:number, height: number) => ({radius, height});
```

위 코드에서 interface Cylinder는 Cylinder타입으로 쓰인다.  
const Cylinder는 Cylinder와 이름은 같지만 값으로 쓰이며 아무런 관련도 없다.  

값으로 쓰일수도, 타입으로 쓰일수도 있다.  

```ts
if(shape instanceof Cylinder) {
  shape.radius; // 에러 발생. '{}' 형식에 'radius' 속성이 없습니다.
}
```

instanceof 는 런타임 연산자이고, 값에 대한 연산을 수행.  
그래서, 타입이 아니라 함수를 참조하게 됨.  
참고로 JS로 컴파일되며 런타임시에는 타입정보가 제거되므로 런타임시 Cylinder 타입에 대한 정보는 없음.  

```ts
type T1 = 'string';
type T2 = 123;
const v1 = 'string';
const v2 = 123;

const p:Person = {first: 'Jane', last: 'Jacobs'};
function Person:Person (first: string, last: string);
```

얼핏 보면 구분하기 힘들 수 있기에 주의해야 한다.  

Class 와 enum은 상황에 따라 타입과 값 두가지 모두 가능한 예약어다.

```ts
class Cylinder {
  height = 1;
  radius = 1;
}

function test(shape:unknown) {
    if(shape instanceof Cylinder) { // interface Cylinder는 에러를 발생시킨다.
        shape.radius
        shape
    }
}
```

위 코드에서 Cylinder 클래스는 타입으로 쓰였다.  
클래스가 타입으로 쓰일때는 속성과 메서드가 사용되지만, 값으로 쓰일 때는 생성자가 사용된다.  

연산자 중에서도 타입에서 쓰일때와 값에서 쓰일 때가 다른 기능을 하는 것들이 존재하는데, 그 중 하나가 typeof 연산자이다.  
```ts
type T1 = typeof P; // 타입에서 쓰임. Person 타입
type T2 = typeof email;
const v1 = typeof p; // 값에서 쓰임. "Object"
const v2 = typeof email; // 값은 "Function"
```

타입의 관점에서, typeof는 타입을 읽어 타입을 반환.  
값의 관점에서, typeof는 JS 런타임의 typeof 연산자가 됨.  

대상 심벌의 런타임 타입 문자열을 반환한다.  
런타임 타입이라는 것은 JS의 타입을 의미하며, 타입스크립트의 타입이 무수히 많은것과 대조적으로 string, number, boolean, undefined, object, function 만이 존재한다.  

그래서, 클래스에 대한 typeof 는 상황에 따라 다르게 동작하게 되는데, 한번 알아 보자.  
```ts
const v = typeof Cylinder; // "function" (클래스가 실제로는 함수로 구현되므로)
type T = typeof Cylinder; // typeof Cylinder 타입
```

v는 이해가 되는데, T는 이해가 잘 가지 않음.  
T 라는 타입은 typeof Cylinder 그 자체가 타입이 됨.  

중요한 점은 Cylinder가 인스턴스 타입이 아니라는 것.  
실제로는 new 키워드를 사용했을 때 볼 수 있는 생성자 함수.  
```ts
type T = typeof Cylinder;

declare let fn:T;
const c = new fn();
```
c의 타입은 Cylinder.  

다음 코드처럼 InstanceType 제너릭을 사용해 생성자 타입과 인스턴스 타입을 전환할 수 있다.  
```ts
type C = instanceType<typeof Cylinder>
```

속성 접근자인 [] 또한 값과 타입으로 사용될 수 있다.  

```ts
const first: Person['first'] = p['first']
```

뿐만 아니라 두 공간 사이에서 다르게 사용되는 경우는 다음과 같다.  
* this  
값으로 쓰이는 this는 자바스크립트의 this 키워드에 해당한다.
타입으로 쓰이는 this는 다형성 this라 불리는 this의 타입스크립트 타입. 서브클래스의 메서드 체인을 구현할 때 유용하다.

* & 와 |
값에서 &와 | 는 비트연산 (각 AND 와 OR), 타입에서는 Intersection과 Union

외에도 const, extends 등이 있다.  

타입스크립트 코드가 잘 동작하지 않는다면, 타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 존재한다.  
아래 코드를 한번 보자.  
options에 단일 객체를 받는다.  

```ts
function email(options:{person:Person, subject:string, body:string}) {
  // ...
}
```

자바스크립트는 객채 내의 각 속성을 로컬 변수로 만들어 주는 구조분해 할당을 사용할 수 있다.  

```js
function email({person, subject, body}) {
  // ...
}
```

그런데, 타입스크립트에서 구조분해 할당을 하면 오류가 발생한다.  
```ts
function email({person:Person, subject:string, body:string}){
  // ...
}
```

바인딩 요소 '~' 에 암시적으로 'any' 형식이 있습니다.
'string' 식별자가 중복되었습니다.  

타입을 지정해준게 아니라, 구조분해할당에서의 변수 생성으로 이해한 것.  
해결하기 위해서는 타입과 값을 구분해야 한다.  

```ts
function email({person, subject, body}:{person:Person, subject:string, body:string}) {
  // ...
}
```

처음에는 혼란스러울 수 있으니 제대로 알고 넘어가도록 하자.  

이번 챕터 내용을 요약하면...  
타입과 값을 확실히 구분하자.  
모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.  
type과 interface는 타입 공간에만 존재하는데, 컴파일 후에는 사라진다.  
class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.  
"foo" 는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있다.  
차이점을 알고 구분할 줄 알아야 한다.  
typeof, this, const, extends 등 많은 연산자와 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

# 타입 단언보다는 타입 선언을 사용하기  

```ts
interface Person { name: string; };
const alice: Person = { name: 'Alice' };
const bob = { name: 'Bob' } as Person;
```

얼핏 보면 결과가 같은 것으로 보이지만, 그렇지 않다.  
첫번째 방법은 alice 변수에 타입을 선언해 변수의 값이 선언된 타입임을 명시한다.  
두변째 방법은 타입 단언을 수행하는데, 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.  

타입 선언을 사용하는게 낫다.  
```ts
const alice: Person = {}; // 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다 라는 에러 발생.
const bob = {} as Person; // 오류가 발생하지 않는다.
```

타입 단언은 강제로 타입을 지정했으므로 속성이 없더라도 Person 타입으로 간주한다.  
bob.name 으로 접근시 오류를 잡아내지 못하고, 런타임시 에러가 발생할 수 있다.  

속성을 추가할 때도 마찬가지인데,  
```ts
const alice: Person = { name: 'Alice', age: 36 };
// 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Person' 형식에 'age'가 없습니다. 라는 오류 발생.

const bob = { name: 'Bob', age: 36 } as Person;
// 오류가 없다!
```
타입 선언문에서는 잉여 속성 체크가 동작했지만, 단언문에서는 적용되지 않았다.  

화살표 함수 사용시 추론된 타입이 모호할 때가 있다.  
```ts
const people = ['alice', 'bob', 'jan'].map(name => ({ name }));
```
people 의 타입은
```
{
    name: string;
}[]
```
인데, Person 타입을 사용하고 싶다.  
타입 단언을 사용하면 될까?  

```ts
const people = ['alice', 'bob', 'jan'].map(name => ({ name } as Person));
```

타입 자체는 Person[] 이 되긴 하나, 위에서 지적된 문제가 그대로 발생한다.  

```ts
const people = ['alice', 'bob', 'jan'].map(name => ({} as Person));
// 오류 없음
```

가장 직관적인것은 화살표 함수 내부에서 타입을 선언하는 것이다.  
```ts
const people = ['alice', 'bob', 'jan'].map(name => {
  const person: Person = {name};
  return person;
});
```

간단한 함수였는데, 꽤나 번잡해졌다.  
더 좋은방법은 화살표 함수의 반환 타입을 선언하는 것이다.  
```ts
const people = ["alice", "bob", "jan"].map((name): Person => ({ name }));
```

위의 번잡한 코드와 동일한 체크를 수행한다.  
괄호의 위치에 따라 의미가 달라질 수 있음에 주의하자.  
(name): Person => ... 는 반환값이 Person 타입이라는 것이고, (name: Person) => ... 는 name 의 타입이 Person 이라는 것이다.  
최종적으로는 다음과 같은데,  
```ts
const people:Person[] = ["alice", "bob", "jan"].map((name): Person => ({ name }));
```

함수 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 한다.  
그래야 정확한 곳에 오류가 표시된다.  

위 내용만 보면 타입 선언만 쓰면 되고 타입 단언은 쓸모가 없어 보인다.  
타입 단언이 필요한 경우를 한번 살펴 보자.  
```ts
document.querySelector('#myButton').addEventLister('click', e => {
  e.currentTarget // 타입은 EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button // 타입은 HTMLButtonElement;
}
```

e.currentTarget 이 HTMLButtonElement인지, HTMLDivElement인지 알지 못한다.  
단지 EventTarget 이라고는 알고 있을뿐.  

우리는 알고 있기에, 타입을 단언해 사용하자.  

as 뿐 아니라 ! 또한 단언문에 될 수 있다.  
```ts
document.getElementById('myButton') // 타입은 HTMLElement | null
document.getElementById('myButton')! // 타입은 HTMLElement
```

null 이 아님을 단언하는 것.  
null 이 아님을 확신할 때 사용하고, 확실하지 않으면 null check 를 해 주자.  

그리고, 타입 단언문을 통해 임의의 타입 간에 변환은 불가능하다.  
A가 B의 부분집합일때, 타입 단언이 가능하다.  
HTMLElement은 HTMLElement | null의 서브타입이고, 변환이 가능하다.  
HTMLButtonElement는 EventTarget의 서브타입이기에 역시 가능하다.  
Person 은 {}의 서브타입이므로 가능하다.  

Person 과 HTMLElement는 서로의 서브타입이 아니므로 불가능하다.  
```
const body = document.body;
const el = body as unknown as Person; // 오류발생
```
굳이 변환하겠다면 unknown 을 사용해야 한다.  
모든 타입은 unknown의 서브타입이므로 오류없이 변환이 가능해진다.  

오류가 없을 뿐이지 위험한 행동임을 유의하자.  

그래서...  
타입단언(as)보다는 타입선언(:)을 사용하자.  
화살표 함수의 반환타입 사용에 유의하자.  
타입스크립트보다 타입을 더 잘 알고있는 경우에 타입단언(as나 !)을 사용하자.

# 객체 래퍼 타입 피하기  
자바스크립트에는 객체 이외에도 Primitive Type이라는 타입이 존재한다.  
기본형들은 불변이며, 메서드를 가지지 않는다는 점에서 객체와 구분된다.  
```js
'primitive'.charAt(3)  
```
위 코드와 같이 마치 메서드를 갖고 있는 것 처럼 보이는데, charAt은 string의 메서드가 아니다.  
string primitive type에는 메서드가 없지만, 자바스크립트에는 String object type이 존재한다.  
이하에서는 string 을 기본형, String을 String 객체라 하자.  
charAt같은 메서드를 사용할 때, 기본형을 String객체로 래핑하고, 메서드를 호출한 후, 마지막에 래핑한 객체를 버린다.  

String.prototype을 몽키패치 해 동작을 한번 보자.  

```js
const originalCharAt = String.prototype.charAt
String.prototype.charAt = function(pos) {
  console.log(this, typeof this, pos);
  originalCharAt.call(this,pos);
}

'test'.charAt(3); // String { 'test' } object 3
```

메서드 내의 this는 String 객체 레퍼.  
String객체를 직접 생성할 수 있으며, 마치 string 기본형처럼 동작한다.  
하지만 항상 같게 동작하는 것은 아닌데, 객체다 보니 eqeqeq 연산자 사용시 같은 문자열이라도 같지 않다고 나온다.  

```js
let x = 'hello';
x.language = 'English';
console.log(x.language);
```

오류 없이 undefined가 출력되는데, x가 String 객체로 변환된 후 language 프로퍼티에 값이 할당된 후 버려졌기에 undefined가 출력 된 것이다.  

String 뿐 만 아니라, Number, Boolean 등 다양한 객체 래퍼 타입이 존재한다.  
객체 래퍼 타입들 덕분에 기본형 값에 메서드를 사용할 수 있는 것이다.  

string 을 사용할 때는 특히 유의해야 한다.  
문제없이 동작하는 경우도 있기 때문이다.  

```js
function getStringLen(foo: String) {
  return foo.length;
}

getStringLen("Hello");
getStringLen(new String("Hello"));
```

둘 다 오류가 없다.  
그러나 string을 매개변수로 받는데, String 래퍼 객체를 전달하면 오류가 발생한다.  

```js
function isGreeting(phrase: String) {
  return ['hello', 'good day'].includes(phrase);
  // 'String' 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다.
  // 'string'은(는) 기본 개체이지만 'String'은(는) 래퍼 개체입니다.
  // 가능한 경우 'string'을(를) 사용하세요.
}
```

일반적으로 래퍼 객체를 직접 생성하는 경우가 거의 없고, 기본형 타입을 객체 래퍼에 할당할 필요도 없기에 그냥 기본형 타입만을 사용하는 것이 낫다.  
new 키워드 없이 Bigint와 Symbol 을 호출하는 경우에는 기본형을 생성하기에 이 경우에는 사용해도 된다.  

요약하자면...  
객체 래퍼 타입의 동작 원리에 대해 알아 두자.  
객체 래퍼 타입 사용은 지양하고 기본형 타입을 사용하자.

## 잉여 속성 체크의 한계 인지하기  

타입이 명시된 변수에 객체 리터럴을 할당할 때 해당 타입의 속성이 있는지, 그외 속성은 없는지 확인한다.  
```ts
interface Room {
  floor:number;
}

const r: Room = {
  floor: 3;
  size: 72.8;
  // 개체 리터럴은 알려진 속성만 지정할 수 있으며, 'Room' 형식에 'size'이(가) 없습니다.
}
```

구조적 타이핑 관점에서는 오류가 발생하지 않아야 한다.  
임시 변수를 통하는 경우를 살펴보자.  

```ts
const obj = {
  floor: 3;
  size: 72.8;
}
const r: Room = obj; // 정상
```

obj 타입은 {floor: number, size:number} 타입으로 추론된다.  
이 Room 타입은 obj타입의 부분집합이 되므로 Room에 할당 가능하며 타입 체커도 통과하게 된다.  

두 코드의 차이점이 뭘까?  
위 코드는 잉여 속성 체크가 수행되었고, 아래 코드는 수행되지 않았다.  
할당 가능 검사(구조적 타이핑 관점)와 잉여 속성 체크는 별개의 작업임을 알면 헷갈리지 않는다.  

잉여 속성 체크가 왜 필요한걸까?  
다음 코드를 한번 보자.  

```ts
interface Options {
  title: string;
  darkMode?: boolean;
}

function createWindow(option: Options) {
  if (options.darkMode) {
    setDarkMode();
  }
  ...
}

createWindow({
  title: 'TODO List',
  darkmode: true
})
```

만약 위 코드가 JS 코드였다면, 아무런 문제 없이 실행되고, setDarkMode는 실행되지 않았을 것이다.  

그러나 타입스크립트의 잉여 속성 체크가 동작해 에러를 잡아낸다.  
개체 리터럴은 알려진 속성만 지정할 수 있지만 'Options' 형식에 'darkmode'이(가) 없습니다.  
'darkMode'을(를) 쓰려고 했습니까?  
라는 오류가 출력된다.  

순수한 구조적 타입 체커는 이러한 종류의 오류를 잡아내지 못한다.  
string타입의 title, boolean타입의 darkMode 속성을 갖는 모든 객체는 Options타입 집합의 원소이다.  
그래서, 타입은 범위가 매우 넓어질 수 있다.  
심지어는 const o1: Options = document; 도 가능하다. title과 darkMode 속성을 갖으므로..  

잉여 속성 체크를 통해 알 수 없는 속성을 허용하지 오류를 미연에 방지한다.  
이를 엄격한 객체 리터럴 체크라고도 한다.  

잉여 속성 체크를 원하지 않으면 인덱스 시그니처를 사용해 추가적인 속성을 예상하도록 할 수 있다.  
```ts
interface Options {
    darkMode?:boolean,
    [otherOptions:string]:unknown;
}

const o: Options = {darkMode: true, test:'test'};
```
아무런 오류가 없다.  
그러나 잉여 속성 체크를 사용하지 않는게 적절한가? 는 뒤에서 다룬다.  

선택적 속성만 갖는 경우는 어떻게 될까?  

```ts
interface Options {
    darkMode?:boolean,
    width?:number,
    height?:number,
}
const opts = {test: 'test'};
const o: Options = opts;
```
임시 변수를 통하므로 잉여 속성 체크가 동작하지 않으므로 오류가 없지 않을까? 싶지만 오류가 발생한다.  
{test: string} 타입과 Options 타입에 공통적인 속성이 있음을 체크하는 별도의 체크를 수행한다.  
공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는 데 효과적이다.  
opts 객체에 선택적인 속성 하나라도 있으면 오류가 사라지게 된다.  

여러 체크가 있는데 정리하자면...  
객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.  
잉여 속성 체크는 구조적 할당 가능성 체크(구조적 타입 체커)와 역할이 다르다.  
잉여 속성 체크는 임시 변수를 통하면 체크를 안할 수 있다.  
정리하면 구조적 타입 체크, 잉여 속성 체크, 공통 속성 체크(모든 속성이 선택적인 경우) 3가지의 체크가 존재하니 잘 사용하자.  

## 함수 표현식에 타입 적용하기  
JS(와 TS)는 함수 표현식과 선언식을 다르게 인식한다.  
함수 표현식을 사용하는 것이 좋은데, 매개변수와 반환값까지 전체를 함수 타입으로 선언해 표현식에 재사용 할 수 있기 때문이다.  
(위와같은 내용 뿐 아니라 표현식은 선언부만 호이스팅되므로 일반적으로 권장되는 방식이다.)  

```ts
type GetPopulationFn = (city:string) => number;
const getPopulation: GetPopulationFn = city => { /* ... */};
```
city에 타입을 지정해주지 않더라도 string 타입임을 알고 있다.  
이게 왜 장점이 되는지 잘 와닿지 않는다.  
다음 예제를 한번 보자.  

```ts
function add(a:number, b:number) {return a + b};
function sub(a:number, b:number) {return a - b};
function mul(a:number, b:number) {return a * b};
function div(a:number, b:number) {return a / b};

type BinaryFn = (a:number, b:number) => number;
const add: BinaryFn = (a, b) => a + b;
const sub: BinaryFn = (a, b) => a - b;
const mul: BinaryFn = (a, b) => a * b;
const div: BinaryFn = (a, b) => a / b;
```

선언식보다 표현식을 사용한 것이 타입 구문이 적어 간결하고, 구현부도 분리되어 있어 로직이 분명해 진다.  

HTTP 요청을 보내는 예제 코드를 한번 보자.  

```ts
async function getQuote() {
  const response = await fetch('API EndPoint');
  const quote = await response.json();
  return quote;
}
```

만약 잘못된 EndPoint거나, 네트워크에 문제가 생겨 200 외의 응답이 온 경우, 잘못될 수 있다.  
'404 Not Found' 가 포함된 내용이 JSON이 아닐 수 있는데, 이 때 response.json()은 JSON 형식이 아니라는 새로운 오류 메시지를 담아 거절된 프로미스를 반환한다.  
호출한 곳에서는 JSON이 아니라는 오류를 받아, 실제 오류인 404 Not Found가 감춰진다.  
또한, fetch 실패하면 거절된 프로미스를 응답하지는 않는다는걸 간과하기 쉽다.  

상태 체크를 수행해 줄 checkedFetch 를 작성해 보자.  

```ts
// lib.dom.d.ts 에 선언된 fetch 타입
declare function fetch(
  input: RequestInfo, init?:RequestInit
): Promise<Response>;
```

```ts
async function checkedFetch(input: RequestInfo, init?:RequestInit) {
  const response = await fetch(input, init);
  if(!response.ok) {
    throw new Error('Request Failed: '+ response.status);
  }
  return response;
}
```
OK 응답이 아닌 경우 json() 호출 이전에 오류를 던져 json 이 아니라는 오류로 인해 숨겨지는 현상을 수정한다.  
이 코드도 잘 동작하지만, 더욱 간결하게 작성할 수 있다.  

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);
  if(!response.ok) {
    throw new Error('Request Failed: '+ response.status);
  }
  return response;
}
```
선언식을 표현식으로 바꾸었고, 함수 전체에 fetch타입을 적용해 input과 init 타입을 추론할 수 있게 했다.  
타입 구문은 또한 checkFetch의 반환 타입을 fetch의 반환 타입과 같음을 보장한다.  
throw 대신 return 을 사용했을 경우, 타입스크립트는 에러를 발견해낸다.  

Type '(input: RequestInfo | URL, init: RequestInit | undefined) => Promise<Response | Error>' is not assignable to type '(input: RequestInfo | URL, init?: RequestInit | undefined) => Promise<Response>'.  
Type 'Promise<Response | Error>' is not assignable to type 'Promise<Response>'.  
Type 'Response | Error' is not assignable to type 'Response'.  

이러한 오류는 물론 선언식에서도 발생하는데, 발생 위치가 다르다.  
선언식은 호출한 위치에서, 표현식은 구현부에서 발생한다.  

요약하자면 다음과 같다.  
1. 매개변수나 반환값에 타입을 직접 명시하기보단 표현식 전체에 타입 구문을 적용하자.  
2. 다른 함수의 시그니처(함수 타입)를 참조하려면 typeof fn 과 같이 사용하면 된다.  
