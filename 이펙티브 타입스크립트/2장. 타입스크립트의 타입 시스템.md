# 타입스크립트의 타입 시스템  

타입스크립트는 자바스크립트로 컴파일하기도 하지만, 가장 중요한 것은 타입 시스템을 제공하는 것.  
2장에서는 이 타입 시스템에 대해 기초부터 알아보도록 하자.  

# 편집기를 사용해 타입 시스템 알아보기.  
타입스크립트는 타입지정이 되어있지 않으면 타입을 추론한다.  
편집기를 통해 해당 시점에서 무슨 타입으로 판단하고 있는지 확인할 수 있다.  

특정 시점에 타입을 어떻게 판단하는지 아는것은 타입 시스템 이해에 큰 도움이 된다.  

```ts
function logMessage(message: string | null) {
  if(message) {
    message // 이 시점에서는 string
  }

}

```

뿐만 아니라 연산자 체인 중간의 타입도 확인할 수 있다.  
편집기는 타입 선언된 곳으로 연결시켜주는 기능을 제공하는데, 이는 오류를 탐지하거나 동작을 이해하는데 큰 도움이 된다.  

# 타입이 값들의 집합이라고 생각하기  

할당 가능한 값들의 집합이 타입이라 생각하자.  
타입의 범위라 부르기도 한다.  

가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, ts 에서는 never 타입에 해당된다.  
그 다음으로 작은 집합은 한가지 값만 포함하는 타입이며, unit 혹은 literal 탕비이라고 한다.  

```ts
type A = 'A';
type B = 'B';
```

여러 타입을 묶으려면 union 타입을 사용한다.  

```ts
type AB = 'A' | 'B';
```
union 타입은 값 또는 타입의 합집합을 의미.  

타입스크립트 오류를 보다 보면 '할당 가능한' 이라는 문구를 볼 수 있는데, 이는 집합의 관점에서 원소(값과 타입의 관계에서), 부분 집합(두 타입의 관계)를 의미한다.  
그래서, 타입 체커의 주요 역할 중 하나는 집합이 다른 집합의 부분집합인지 검사하는 것이라고 볼 수 있겠다.  

다음처럼 원소를 서술하는 방법도 존재한다.  

```ts
interface Identified {
  id: string;
}
```
위의 인터페이스가 타입(Identified) 범위 내의 값들에 대한 설명(타입 명세)이라고 생각해 보자.  
어떤 객체가 string 으로 할당 가능한 id 속성을 가지고 있다면 그 객체는 Identified이다.  

구조적 타이핑 규칙에서 말했듯, 어떠한 값이 해당 타입의 속성뿐만 아니라 다른 속성도 가질 수 있음을 의미한다.  
추가 속성을 허용하지 않는 excess property checking개념만 생각하다 보면 놓치기 쉽다.  

```ts
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

& 연산자는 두 타입의 intersection(교집합)을 계산한다.  
공통 속성이 없으므로 never타입인가? 라 생각할 수 있으나, 타입 연산자는 인터페이스 속성이 아니라, 값의 집합(타입의 범위)에 적용된다.  

그래서, name 속성을 갖는 Person 범위와 birth, death? 속성을 갖는 Lifespan 범위의 교집합은 name, birth, death? 속성을 갖는 범위가 된다.  
Person -> name 속성을 갖는 모든 객체, Lifespan -> birth, death? 속성을 갖는 모든 객체이므로 두 범위의 교집합은 세 속성을 갖는 모든 객체가 되는 것.  
객체를 Person 으로 봐도 문제가 없고, Lifespan으로 봐도 문제가 없어야 한다.  
그러려면 두 타입의 모든 속성을 가져야 하기 때문에 교집합은 모든 속성을 갖는 객체가 된다.  

Person 과 Lifespan 을 둘 다 가지는 값은 인터섹션 타입에 속하게 된다.  
동일하게 세 속성 말고 다른 속성을 더 가지는 값도 PersonSpan 타입에 속한다.

두 인터페이스의 union인 | 연산자는 좀 다르게 동작하는데, 아래 예제를 살펴 보자.  
```ts
type K = keyof (Person | LifeSpan);
```

K는 never.  
위 코드는 Person 타입 또는 LifeSpan 타입인 타입의 key를 갖고와 리터럴 타입으로 정의하는데, 정리해 보면 다음과 같다.  

Person 타입 이거나, LifeSpan 타입이어야 한다.  
그래서, union 연산자를 통해 만들어진 타입(이라고 해 보자)의 속성은 Person 에 있는 속성일수도 있고, LifeSpan에 있는 속성일 수 있다.  
해당 속성들이 확실히 존재한다는 보장을 하지 못하므로 TS는 두 인터페이스에 공통적으로 속한 속성만 인정하는 것이다.  
그래서, 인터페이스에서의 union연산은 공통된 속성만 갖으므로 keyof 연산자를 통하면 never가 된다.  

아래 연산자를 잘 이해하면 크게 도움이 될 것이다.  
```ts
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

일반적으로 위 Person과 LifeSpan 예제에서는 extends를 사용한다.  
이 extends키워드의 의미는 '할당 가능한' 과 비슷하게, '~의 부분집합'이라는 의미로도 받아들일 수 있다.  

```
interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth:Date;
  death?:Date;
}
```

PersonSpan 타입의 모든 값은 string 타입의 name 속성을 가져야 한다.  
그리고 birth 속성을 가져야 제대로 된 부분집합인 PersonSpan이라 할 수 있다.  

서브타입은 어떤 집합이 다른 집합의 부분집합이라는 의미가 된다.  
클래스 관점에서는 서브클래스가 된다.  

```
interface Vector1D { x: number;}
interface Vector2D extends Vector1D { y: number;}
interface Vector3D extedns Vector2D { z: number;}
```

이 관계는 상속관계로 그려지지만, 벤 다이어그램으로 그리는게 더 적절하다.  

string 타입의 name을 갖는 객체는 모두 Person 객체이다.  
그 중에서, birth 속성을 갖는 객체는 Person이기도 하며, Person의 부분집합이며, 이를 PersonSpan이라 이름지은 것이다.  
extends 없이도 작성이 가능하지만, 리터럴 타입과 유니온 타입에 대해 생각해 본다면 집합 스타일이 더 직관적이다.  

```
interface Vector1D { x: number;}
interface Vector2D { x: number; y: number;}
interface Vector3D { x: number; y: number; z: number;}
```

extends 키워드는 제네릭 타입에서 한정자로도 쓰이며, 이 문맥에서는 ~의 부분집합을 의미하기도 한다.  

```ts

function getKey<K extends string>(val:any, key: K) {
  // ...
}

```

string을 상속 관점에서 생각하면 이해하기 어렵지만, 부분집합 관점에서 생각하면 이해하기 쉽다.  
K는 string의 부분집합.  
string, 'a', '3' 등 모두 가능해 지는 것.  

``` ts
getKey({}, 'x'); // 'x' 는 string을 상속(부분집합), 오류 없음
getKey({}, Math.random() < 0.5 ? 'a' : 'b'); // 'a' | 'b' 는 string을 상속(부분집합), 오류 없음
getKey({}, document.title); // string은 string을 상속(부분집합), 오류 없음
getKey({}, 12); // 오류
```

12를 넘겨주면 ~에 할당될 수 없습니다 라는 문구가 출력되는데, 이는 상속의 관점에서 상속할 수 없습니다로 바꿀 수 있고, 상속 관점에서는 ~의 부분집합이 될 수 없습니다. 로 이해 가능하다.  
할당과 상속 관점으로 전환하면 keyof T 를 이해하기 수월해 진다.  

```ts
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point // "x" | "y"

function sortBy<K extends keyof T, T>(vals: T[], key: K):T[] {
  // ...
}

const pts: Point[] = [{x: 1, y: 1} , {x: 2, y: 0}];
sortBy(pts, 'x'); // 정상, 'x' 는 'x' | 'y' 를 상속(또는 keyof T('x' | 'y') 의 부분집합).
sortBy(pts, 'y'); // 똑같이 정상
sortBy(pts, Math.random() < 0.5 ? 'x' : 'y'); // 정상 'x' | 'y' 는 'x' | 'y' 를 상속.
sortBy(pts, 'z'); // 오류. '"z"' 형식의 인수는 '"x" | "y"'형식의 매개변수에 할당될 수 없습니다.
```

타입들이 엄격한 상속관계가 아니라면 집합 스타일이 더욱 바람직함.  
string | number와 string | Date 사이의 Intersection은 공집합이 아니라 string이며, 서로의 부분집합도 아니다.  

위 내용들을 한번 정리해 보자.  

타입을 값의 집합으로 생각하면 이해하기 편하다.(타입의 범위)  
이 집합은 유한(boolean, 리터럴) 하거나 무한(string, number)하다.  
타입스크립트의 타입은 엄격한 상속관계가 아니라 겹쳐지는 집합으로 표현된다.  
두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.  
한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.(구조적 타이핑)  
타입 연산은 집합의 범위에 적용된다.  
A와 B의 인터섹션은 A와 B의 범위의 인터섹션, 객체 타입에서는 A & B 인 값이 A 와 B의 속성을 모두 가짐을 의미 (A | B 는 공통적인 속성만 가짐을 의미)  
상속, 할당가능, 서브타입, 부분집합 은 같은 의미.

```ts
interface A {
  common: string;
  a: string;  
}

interface B {
  common: string;
  b: string;
}

keyof (A&B) = (keyof A) | (keyof B)
// 우변 : "common" | "a" 와 "common" | "b" 의 합집합 -> "common" | "a" | "b"
// 좌변 : 집합의 범위에서 생각. A이면서 B이려면 모든 속성을 가져야 함. -> A와 B의 모든 속성을 가짐.

keyof (A|B) = (keyof A) & (keyof B)
// 우변 : "common" | "a" 와 "common" | "b" 의 교집합 -> "common"
// 좌변 : 집합의 범위에서 생각. A거나 B이면 확실한 속성은 common, 'a'와 'b' 는 있을수도, 없을수도 있기에 제외 -> "common"
```

# 타입 공간과 값 공간의 심벌 구분하기  
심벌이 같더라도, 속하는 공간에 따라 다른것을 나타낼 수 있기에, 주의해야 한다.  

```ts
interface Cylinder {
  height: number;
  radius: number;
}

const Cylinder = (radius:number, height: number) => ({radius, height});
```

위 코드에서 interface Cylinder는 Cylinder타입으로 쓰인다.  
const Cylinder는 Cylinder와 이름은 같지만 값으로 쓰이며 아무런 관련도 없다.  

값으로 쓰일수도, 타입으로 쓰일수도 있다.  

```ts
if(shape instanceof Cylinder) {
  shape.radius; // 에러 발생. '{}' 형식에 'radius' 속성이 없습니다.
}
```

instanceof 는 런타임 연산자이고, 값에 대한 연산을 수행.  
그래서, 타입이 아니라 함수를 참조하게 됨.  
참고로 JS로 컴파일되며 런타임시에는 타입정보가 제거되므로 런타임시 Cylinder 타입에 대한 정보는 없음.  

```ts
type T1 = 'string';
type T2 = 123;
const v1 = 'string';
const v2 = 123;

const p:Person = {first: 'Jane', last: 'Jacobs'};
function Person:Person (first: string, last: string);
```

얼핏 보면 구분하기 힘들 수 있기에 주의해야 한다.  

Class 와 enum은 상황에 따라 타입과 값 두가지 모두 가능한 예약어다.

```ts
class Cylinder {
  height = 1;
  radius = 1;
}

function test(shape:unknown) {
    if(shape instanceof Cylinder) { // interface Cylinder는 에러를 발생시킨다.
        shape.radius
        shape
    }
}
```

위 코드에서 Cylinder 클래스는 타입으로 쓰였다.  
클래스가 타입으로 쓰일때는 속성과 메서드가 사용되지만, 값으로 쓰일 때는 생성자가 사용된다.  

연산자 중에서도 타입에서 쓰일때와 값에서 쓰일 때가 다른 기능을 하는 것들이 존재하는데, 그 중 하나가 typeof 연산자이다.  
```ts
type T1 = typeof P; // 타입에서 쓰임. Person 타입
type T2 = typeof email;
const v1 = typeof p; // 값에서 쓰임. "Object"
const v2 = typeof email; // 값은 "Function"
```

타입의 관점에서, typeof는 타입을 읽어 타입을 반환.  
값의 관점에서, typeof는 JS 런타임의 typeof 연산자가 됨.  

대상 심벌의 런타임 타입 문자열을 반환한다.  
런타임 타입이라는 것은 JS의 타입을 의미하며, 타입스크립트의 타입이 무수히 많은것과 대조적으로 string, number, boolean, undefined, object, function 만이 존재한다.  

그래서, 클래스에 대한 typeof 는 상황에 따라 다르게 동작하게 되는데, 한번 알아 보자.  
```ts
const v = typeof Cylinder; // "function" (클래스가 실제로는 함수로 구현되므로)
type T = typeof Cylinder; // typeof Cylinder 타입
```

v는 이해가 되는데, T는 이해가 잘 가지 않음.  
T 라는 타입은 typeof Cylinder 그 자체가 타입이 됨.  

중요한 점은 Cylinder가 인스턴스 타입이 아니라는 것.  
실제로는 new 키워드를 사용했을 때 볼 수 있는 생성자 함수.  
```ts
type T = typeof Cylinder;

declare let fn:T;
const c = new fn();
```
c의 타입은 Cylinder.  

다음 코드처럼 InstanceType 제너릭을 사용해 생성자 타입과 인스턴스 타입을 전환할 수 있다.  
```ts
type C = instanceType<typeof Cylinder>
```

속성 접근자인 [] 또한 값과 타입으로 사용될 수 있다.  

```ts
const first: Person['first'] = p['first']
```

뿐만 아니라 두 공간 사이에서 다르게 사용되는 경우는 다음과 같다.  
* this  
값으로 쓰이는 this는 자바스크립트의 this 키워드에 해당한다.
타입으로 쓰이는 this는 다형성 this라 불리는 this의 타입스크립트 타입. 서브클래스의 메서드 체인을 구현할 때 유용하다.

* & 와 |
값에서 &와 | 는 비트연산 (각 AND 와 OR), 타입에서는 Intersection과 Union

외에도 const, extends 등이 있다.  

타입스크립트 코드가 잘 동작하지 않는다면, 타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 존재한다.  
아래 코드를 한번 보자.  
options에 단일 객체를 받는다.  

```ts
function email(options:{person:Person, subject:string, body:string}) {
  // ...
}
```

자바스크립트는 객채 내의 각 속성을 로컬 변수로 만들어 주는 구조분해 할당을 사용할 수 있다.  

```js
function email({person, subject, body}) {
  // ...
}
```

그런데, 타입스크립트에서 구조분해 할당을 하면 오류가 발생한다.  
```ts
function email({person:Person, subject:string, body:string}){
  // ...
}
```

바인딩 요소 '~' 에 암시적으로 'any' 형식이 있습니다.
'string' 식별자가 중복되었습니다.  

타입을 지정해준게 아니라, 구조분해할당에서의 변수 생성으로 이해한 것.  
해결하기 위해서는 타입과 값을 구분해야 한다.  

```ts
function email({person, subject, body}:{person:Person, subject:string, body:string}) {
  // ...
}
```

처음에는 혼란스러울 수 있으니 제대로 알고 넘어가도록 하자.  

이번 챕터 내용을 요약하면...  
타입과 값을 확실히 구분하자.  
모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.  
type과 interface는 타입 공간에만 존재하는데, 컴파일 후에는 사라진다.  
class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.  
"foo" 는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있다.  
차이점을 알고 구분할 줄 알아야 한다.  
typeof, this, const, extends 등 많은 연산자와 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.
