# 1. 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 독특한 언어인데, 인터프리터 방식으로 실행되는 것도 아니고, 저수준 언어로 컴파일 되는것도 아니다.  
같은 고수준 언어인 자바스크립트로 컴파일되며, 이 자바스크립트가 실행된다.  
자바스크립트와의 관계를 잘 파악하는것이 중요하다.  
타입스크립트의 타입 시스템 또한 독특한 특징을 갖는데, 자세히 알아보도록 하자.

## 1. 타입스크립트와 자바스크립트의 관계 이해하기

> _"타입스크립트는 자바스크립트의 상위집합(superset)이다"_

그래서, 자바스크립트 프로그램에 문법적 오류가 없으면, 타입스크립트 프로그램이라고 할 수 있다.  
자바스크립트 프로그램에 어떤 이슈가 존재하면, 타입 체커에게 지적당할 가능성이 높다.

그러나, 문법 유효성과 동작에서의 이슈는 독립적이다.  
이슈가 있더라도 타입스크립트는 여전히 코드를 파싱하고 자바스크립트로 변환할 수 있다.

main.js 를 main.ts 로 바꾼다고 해도 달라지는 것은 없으며, Migration에 엄청난 이점을 가져다 준다.  
일부분에만 타입스크립트를 적용할 수 있기 때문이며, C 나 Java 등 다른 언어로의 Migration을 생각하면 다시 작성하는게 더 좋을정도로 어려울 수 있다.

모든 타입스크립트 프로그램이 자바스크립트인 것은 아닌데, 다음 예제를 한번 보자.

```typescript
function greet(who: string) {
  console.log("Hello", who);
}
```

위 코드를 실행시키면, Syntax Error를 발생시킨다.  
_' : string'_ 은 타입스크립트에서만 사용되므로 자바스크립트 프로그램 범위를 벗어나게 되는 것이다.

타입스크립트 컴파일러는 일반 자바스크립트 프로그램에서도 유용한데, 다음 예제를 보자.

```javascript
let city = "seoul";
console.log(city.toUppercase());
```

자바스크립트에서는 city.toUppercase is not a function 에러를 출력하지만 타입스크립트에서는 조금 더 나아간다.

> 'toUppercase' 속성이 'string' 형식에 없습니다.  
> 'toUpperCase' 를 사용하시겠습니까?

초기값으로 타입을 추론하여 문제점을 찾아주고 있다.

타입시스템의 목표 중 하나는 런타임에 발생될 오류를 미리 찾아내는것이다.  
정적 타입 언어라는 것은 이런 특징을 말하는 것.

여러 문제중 몇가지를 찾아내기도 하는데, 아래 예제를 한번 보자.

```javascript
const customers = [
  { id: 1, age: 13 },
  { id: 2, age: 15 },
  { id: 3, age: 17 },
];

for (const customer of customers) {
  console.log(customer.abe);
}
```

age를 실수로 abe로 입력해 오타가 났을 경우,
자바스크립트에서는 결과가 undefined 3개가 찍혀 나올것이다.  
문법적으로 문제 없으니 유효한 자바스크립트(타입스크립트)이며, 어떠한 오류도 발생하지 않는다.  
이런 경우, 타입스크립트의 타입 체커는 오류를 찾아낸다.

> 'abe' 속성이 ... 형식에 없습니다.  
> 'age' 를 사용하시겠습니까?

타입을 설정하면 더욱 더 많은 오류를 찾아낼 수 있다.

```javascript
const customers = [
  { id: 1, abe: 13 },
  { id: 2, abe: 15 },
  { id: 3, abe: 17 },
];

for (const customer of customers) {
  console.log(customer.age);
}
```

> 'age' 속성이 ... 형식에 없습니다.  
> 'abe' 를 사용하시겠습니까?

어느것이 오타인지 판단하지는 못한다.  
이럴 때, 타입을 추가하면 판단이 가능해 진다.

```typescript
interface Customer {
  id: number;
  age: number;
}

const customers: Customer[] = [
  { id: 1, abe: 13 },
  { id: 2, abe: 15 },
  { id: 3, abe: 17 },
];

for (const customer of customers) {
  console.log(customer.age);
}
```

> 개체 리터럴은 알려진 속성한 지정할 수 있지만  
> 'Customer' 형식에 'abe'가 없습니다.  
> 'age'을(를) 쓰려고 했습니까?

오류가 어디서 발생했는데, 해결책도 올바르게 제시한다.  
타입은 또다른 오류를 찾을 수 있게 해 주는데, 다음 오류를 한번 보자.

```typescript
const customers: Customer[] = [
  { id: 1, age: 13 },
  { id: 2, abe: 15 },
  { id: 3, age: 17 },
];
```

> 'age'을(를) 쓰려고 했습니까?

배열 내부에서의 오타 오류또한 찾아주고 있다.  
만약 타입 구문이 없었다면 아무런 오류없이 실행되었을 것이다.

이 내용을 정리하면, 자바스크립트와 타입스크립트의 superset 구조에서 타입스크립트 내부에 자바스크립트 일부와 교집합이 생기는 새로운 영역을 추가할 수 있다.

타입 체커를 통과한 타입스크립트 프로그램 이라 명명한다.
이 타입 체커는 때때로 정상 동작하는 코드에 오류를 표시하기도 한다.

```typescript
const a = null + 7;
const b = [] + 7;
alert("hello", "typescript");
```

프로그램에 오류가 발생하지 않았더라도, 타입 체커가 오류를 표시할 수 있다는 것이다.  
사용 할 지 안할지는 선택에 달려있지만, 채택한다면 오류가 적은 코드를 작성할 수 있다.
타입 체커가 모든 오류를 표시해주는 것은 아니다.

```typescript
const names = ["Alice", "Bob"];
console.log(names[2].toUpperCase());
```

> TypeError: Cannot read property 'toUpperCase' of undefined

타입스크립트는 배열이 범위 내에서 사용될 것이라 가정해 names[2]가 string 타입일 것으로 예상했지만, 실제로는 undefined이며 런타임시에 오류가 발생했다.

2. 타입스크립트 설정 이해하기

# 2. 타입스크립트 설정 이해하기

다음 코드가 문제 없이 타입 체커를 통과할까?

```ts
function add(a, b) {
  return a + b;
}
add(10, null);
```

정답은 ?

> 설정에 따라 다르다

설정들은 tsconfig.json 을 통해 가능하다.

noImplicityAny와 strictNullChecks 이해를 해 보자.

noImplicityAny가 false면

타입을 지정해주지 않을 시 기본적으로 any 타입을 갖게 되는데 이를 암시적 any라 부른다. any는 강력하지만 타입 체커를 무력화 시키므로 조심해서 사용해야 한다.

noImplicityAny가 true면

타입을 지정해주지 않을 시 오류를 발생시킨다.

명시적으로 any타입을 지정 해 주거나, 분명한 타입을 지정해 주어 해결할 수 있다.

strictNullChecks 는 null과 undefined가 모든 타입에서 허용되는지 여부인데, 다음 코드를 보자.

```ts
const x: number = null; // 또는 undefined
```

strictNullChecks 가 설정되었으면 오류를 출력하고, 설정되어있지 않으면 오류가 없는 유효한 코드가 된다.

```ts
const x: number | null = null;
```

명시적으로 작성 해 주자.

그리고, 이 x를 이렇게 사용하면, nullCheck 코드나 단언문(as 또는 !)을 사용해야 한다.

오류를 찾아내는 데 많은 도움을 주지만, 코드 작성을 어렵게 한다.

# 코드 생성과 타입이 관계없음을 이해하기

ts compiler 는 구버전의 js로 트랜스파일하고, 타입 오류를 체크한다.

두 가지가 독립적인데, js에는 타입 오류라는 개념이 없으므로 트랜스파일이 가능하다.

타입스크립트의 타입 오류는 다른 언어에서의 Warning과 비슷하다.

만약 오류가 있을때 컴파일을 하지 않기를 원하면, noEmitOnError 를 설정하자.

> 런타임에는 타입 체크가 불가능하다.

```ts
interface Square {
  width: number;
}

interface Rectangle extends Shape {
  height: number;
}

type Shape = Square | Rectangle;

function calc(shape: Shape) {
  if (shape instanceof Rectangle) {
    console.log("test");
  }
}
```

instanceof 체크는 런타임에 실시되지만, Rectangle은 타입이기 때문에 컴파일 과정에서 사라지고, 체크가 불가능해 진다.

타입 정보를 기억할 순 없을까?

```ts
function calc(shape: Shape) {
  if ("height" in shape) {
    console.log("test");
  }
}
```

속성을 체크하기.

또 다른 방법으로는 런타임에 접근가능한 타입 정보를 명시적으로 저장하는 방법이 있다.

```ts
interface Square {
  kind: "square";
  width: number;
}

interface Rectangle extends Shape {
  kind: "rectangle";
  height: number;
}

function calc(shape: Shape) {
  if (shape.kind === "rectangle") {
    console.log("test");
  }
}
```

또 다른 방법으로는 클래스화 시키는것이 있다.

클래스화 시키면

```ts
type Shape = Square | Rectangle;
```

위 코드에서는 타입으로 참조되나

```ts
function calc(shape: Shape) {
  if (shape instanceof Rectangle) {
    console.log("test");
  }
}
```

위 코드에서는 값으로 참조된다.  

> 타입 연산은 런타임에 영향을 주지 않는다.  

값을 정제하는 아래 예제를 한번 보자.  

```ts
function asNumber(val:number | string):number {
  return val as number;
}
```

위 함수는 다음과 같이 변환된다.  

```ts
function asNumber(val) {
  return val;
}
```
as number는 타입 연산이고, 아무런 영향을 주지 않는다.  
값을 정제하기 위해서는 런타임의 타입을 체크해야 한다.  

```ts
function asNumber(val:number | string):number {
  return typeof(val) === 'string' ? Number(val) : val;
}
```

> 런타임 타입은 선언된 타입과 다를 수 있다.

```ts
function func(value: boolean) {
  switch(value){
    case true:
      console.log('true');
      break;
    case false:
      console.log('false');
      break;
    default:
      console.log('?');
  }
```

ts는 일반적으로 dead 코드를 찾아내지만 위 코드에서는 잡아내지 못한다.  

: boolean 이 부분이 타입 선언임에 주의하자.  

```ts
const response = await fetch('');
const result:boolean = await response.json();
func(result);
```

이렇게 호출했을 경우, result에 boolean 값이 들어간다는 보장은 없다.  

만약 잘못 파악해서 "True" 나 "False" 값이 올 수도 있고, 호출에 실패하는 경우도 생길 수 있다.  
선언된 타입이 달라질 수 있음을 유의하자.  

> 타입스크립트의 타입으로 함수 오버로드가 불가능하다.  

다른 언어에서, 매개변수만 다른 동일한 이름의 함수를 사용하는것을 함수 오버로딩이라 하는데, 타입스크립트에서는 불가능하다.  

왜 ? 자바스크립트로 컴파일되는 과정에서 타입선언은 모두 없어져버리기 때문.  

> 타입스크립트의 타입은 성능에 영향을 주지 않는다.  
자바스크립트로 컴파일되며 타입과 타입 연산자가 제거되므로, 런타임 성능에 전혀 영향을 주지 못한다.  

그래서, 정리해 보면 다음과 같다.  
타입스크립트의 타입선언과 타입 연산자는 자바스크립트로 변환되어 날라가게 되므로, 성능적으로 아무런 영향을 끼치지 못한다.  
타입 오류가 존재하더라도 컴파일은 가능하다.  
런타임의 타입 지정을 위해서는 타입스크립트 타입 지정으로는 불가능하며 별도의 방법을 사용해야 한다.  

# 구조적 타이핑에 익숙해지기  

JS는 Duck Typing 기반.  
Duck Typing이란 어떤 타입에 부합하는 변수와 메서드를 가질 경우, 해당 객체를 해당 타입에 속하는 것으로 간주하는 방식.  

```ts
interface Vector2D {
  x: number;
  y: number;
}

function calcLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}
```

이 상황에서 이름 속성이 추가된 벡터를 한번 보자.  

```ts
interface NamedVector {
  name: string;
  x: number;
  y: number;
}

const v: NamedVector { x: 3, y: 4, name: 'Kim'};
calcLength(v); // 정상 실행됨
```

상속이나 확장같은 관계 선언 없이 Vector2D를 입력으로 받는 함수를 사용하고 있다.  
NamedVector의 구조가 Vector2D와 호환되기 때문에 함수 호출이 가능한 것.  

반면 이로 인해 문제점이 발생할 수 있다.  

```ts
interface Vecotr3D {
  x: number;
  y: number;
  z: number;
}

function normalize(v: Vector3D) {
  const length = calcLength(v);

  return {
    x: v.x / length,
    y: v.y / length,
    z: v.z / length
  }
}

```

Vector3D의 구조가 Vector3D와 호환되기에 실행은 정상적으로 이루어지나, 결과는 예상한 것과 다르게 나타난다.  
z가 정규화 과정에서 무시되었지만 타입 체커는 오류라고 인식하지 않는다.(이를 오류라고 처리하는 설정이 존재하긴 함)  

그래서 중요한 점은 함수를 작성할 때, 호출에 사용되는 매개변수의 속성들이 타입에 선언된 정확한 속성만을 가질거라 생각하기 쉬우나 타입스크립트에서는 타입이 열려있으므로 선언된 속성 뿐 아니라 다른 속성도 타입에 포함될 수 있다.  

이 구조적 타이핑은 클래스와 관련된 할당문에서도 적용된다.  

```ts

Class C {
  foo: string;
  constructor(foo: string) {
    this.foo = foo;
  }
}

const c = new C('string');
const d: C = { foo: 'string' }; // 정상
```

d는 string 타입의 foo 속성을 갖고, 생성자에 별다른 로직이 없으므로 C타입이라고 볼 수 있는것이다.  
이로 인해 인스턴스 역시 예상과 다를 수 있다.  

# any 타입 지양하기  
any 타입은 이미 아는 내용이므로 간단하게 정리하고 넘어가자.  
any 타입은 매우 강력하다.  
타입 체커와 확장 프로그램(자동완성) 등을 무력화시킨다.  
any 타입은 타입스크립트의 의미를 퇴색시키며 문제점을 숨길 수 있다.  
최대한 사용을 지양하도록 하자.
