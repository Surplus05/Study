# 1. 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 독특한 언어인데, 인터프리터 방식으로 실행되는 것도 아니고, 저수준 언어로 컴파일 되는것도 아니다.  
같은 고수준 언어인 자바스크립트로 컴파일되며, 이 자바스크립트가 실행된다.  
자바스크립트와의 관계를 잘 파악하는것이 중요하다.  
타입스크립트의 타입 시스템 또한 독특한 특징을 갖는데, 자세히 알아보도록 하자.

## 1. 타입스크립트와 자바스크립트의 관계 이해하기

> _"타입스크립트는 자바스크립트의 상위집합(superset)이다"_

그래서, 자바스크립트 프로그램에 문법적 오류가 없으면, 타입스크립트 프로그램이라고 할 수 있다.  
자바스크립트 프로그램에 어떤 이슈가 존재하면, 타입 체커에게 지적당할 가능성이 높다.

그러나, 문법 유효성과 동작에서의 이슈는 독립적이다.  
이슈가 있더라도 타입스크립트는 여전히 코드를 파싱하고 자바스크립트로 변환할 수 있다.

main.js 를 main.ts 로 바꾼다고 해도 달라지는 것은 없으며, Migration에 엄청난 이점을 가져다 준다.  
일부분에만 타입스크립트를 적용할 수 있기 때문이며, C 나 Java 등 다른 언어로의 Migration을 생각하면 다시 작성하는게 더 좋을정도로 어려울 수 있다.

모든 타입스크립트 프로그램이 자바스크립트인 것은 아닌데, 다음 예제를 한번 보자.

```typescript
function greet(who: string) {
  console.log("Hello", who);
}
```

위 코드를 실행시키면, Syntax Error를 발생시킨다.  
_' : string'_ 은 타입스크립트에서만 사용되므로 자바스크립트 프로그램 범위를 벗어나게 되는 것이다.

타입스크립트 컴파일러는 일반 자바스크립트 프로그램에서도 유용한데, 다음 예제를 보자.

```javascript
let city = "seoul";
console.log(city.toUppercase());
```

자바스크립트에서는 city.toUppercase is not a function 에러를 출력하지만 타입스크립트에서는 조금 더 나아간다.

> 'toUppercase' 속성이 'string' 형식에 없습니다.  
> 'toUpperCase' 를 사용하시겠습니까?

초기값으로 타입을 추론하여 문제점을 찾아주고 있다.

타입시스템의 목표 중 하나는 런타임에 발생될 오류를 미리 찾아내는것이다.  
정적 타입 언어라는 것은 이런 특징을 말하는 것.

여러 문제중 몇가지를 찾아내기도 하는데, 아래 예제를 한번 보자.

```javascript
const customers = [
  { id: 1, age: 13 },
  { id: 2, age: 15 },
  { id: 3, age: 17 },
];

for (const customer of customers) {
  console.log(customer.abe);
}
```

age를 실수로 abe로 입력해 오타가 났을 경우,
자바스크립트에서는 결과가 undefined 3개가 찍혀 나올것이다.  
문법적으로 문제 없으니 유효한 자바스크립트(타입스크립트)이며, 어떠한 오류도 발생하지 않는다.  
이런 경우, 타입스크립트의 타입 체커는 오류를 찾아낸다.

> 'abe' 속성이 ... 형식에 없습니다.  
> 'age' 를 사용하시겠습니까?

타입을 설정하면 더욱 더 많은 오류를 찾아낼 수 있다.

```javascript
const customers = [
  { id: 1, abe: 13 },
  { id: 2, abe: 15 },
  { id: 3, abe: 17 },
];

for (const customer of customers) {
  console.log(customer.age);
}
```

> 'age' 속성이 ... 형식에 없습니다.  
> 'abe' 를 사용하시겠습니까?

어느것이 오타인지 판단하지는 못한다.  
이럴 때, 타입을 추가하면 판단이 가능해 진다.

```typescript
interface Customer {
  id: number;
  age: number;
}

const customers: Customer[] = [
  { id: 1, abe: 13 },
  { id: 2, abe: 15 },
  { id: 3, abe: 17 },
];

for (const customer of customers) {
  console.log(customer.age);
}
```

> 개체 리터럴은 알려진 속성한 지정할 수 있지만  
> 'Customer' 형식에 'abe'가 없습니다.  
> 'age'을(를) 쓰려고 했습니까?

오류가 어디서 발생했는데, 해결책도 올바르게 제시한다.  
타입은 또다른 오류를 찾을 수 있게 해 주는데, 다음 오류를 한번 보자.

```typescript
const customers: Customer[] = [
  { id: 1, age: 13 },
  { id: 2, abe: 15 },
  { id: 3, age: 17 },
];
```

> 'age'을(를) 쓰려고 했습니까?

배열 내부에서의 오타 오류또한 찾아주고 있다.  
만약 타입 구문이 없었다면 아무런 오류없이 실행되었을 것이다.

이 내용을 정리하면, 자바스크립트와 타입스크립트의 superset 구조에서 타입스크립트 내부에 자바스크립트 일부와 교집합이 생기는 새로운 영역을 추가할 수 있다.

타입 체커를 통과한 타입스크립트 프로그램 이라 명명한다.
이 타입 체커는 때때로 정상 동작하는 코드에 오류를 표시하기도 한다.

```typescript
const a = null + 7;
const b = [] + 7;
alert("hello", "typescript");
```

프로그램에 오류가 발생하지 않았더라도, 타입 체커가 오류를 표시할 수 있다는 것이다.  
사용 할 지 안할지는 선택에 달려있지만, 채택한다면 오류가 적은 코드를 작성할 수 있다.
타입 체커가 모든 오류를 표시해주는 것은 아니다.

```typescript
const names = ["Alice", "Bob"];
console.log(names[2].toUpperCase());
```

> TypeError: Cannot read property 'toUpperCase' of undefined

타입스크립트는 배열이 범위 내에서 사용될 것이라 가정해 names[2]가 string 타입일 것으로 예상했지만, 실제로는 undefined이며 런타임시에 오류가 발생했다.

2. 타입스크립트 설정 이해하기
