# 1. 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 독특한 언어인데, 인터프리터 방식으로 실행되는 것도 아니고, 저수준 언어로 컴파일 되는것도 아니다.  
같은 고수준 언어인 자바스크립트로 컴파일되며, 이 자바스크립트가 실행된다.  
자바스크립트와의 관계를 잘 파악하는것이 중요하다.  
타입스크립트의 타입 시스템 또한 독특한 특징을 갖는데, 자세히 알아보도록 하자.

## 1. 타입스크립트와 자바스크립트의 관계 이해하기

> _"타입스크립트는 자바스크립트의 상위집합(superset)이다"_

그래서, 자바스크립트 프로그램에 문법적 오류가 없으면, 타입스크립트 프로그램이라고 할 수 있다.  
자바스크립트 프로그램에 어떤 이슈가 존재하면, 타입 체커에게 지적당할 가능성이 높다.

그러나, 문법 유효성과 동작에서의 이슈는 독립적이다.  
이슈가 있더라도 타입스크립트는 여전히 코드를 파싱하고 자바스크립트로 변환할 수 있다.

main.js 를 main.ts 로 바꾼다고 해도 달라지는 것은 없으며, Migration에 엄청난 이점을 가져다 준다.  
일부분에만 타입스크립트를 적용할 수 있기 때문이며, C 나 Java 등 다른 언어로의 Migration을 생각하면 다시 작성하는게 더 좋을정도로 어려울 수 있다.

모든 타입스크립트 프로그램이 자바스크립트인 것은 아닌데, 다음 예제를 한번 보자.

```typescript
function greet(who: string) {
  console.log("Hello", who);
}
```

위 코드를 실행시키면, Syntax Error를 발생시킨다.  
_' : string'_ 은 타입스크립트에서만 사용되므로 자바스크립트 프로그램 범위를 벗어나게 되는 것이다.

타입스크립트 컴파일러는 일반 자바스크립트 프로그램에서도 유용한데, 다음 예제를 보자.

```javascript
let city = "seoul";
console.log(city.toUppercase());
```

자바스크립트에서는 city.toUppercase is not a function 에러를 출력하지만 타입스크립트에서는 조금 더 나아간다.

> 'toUppercase' 속성이 'string' 형식에 없습니다.  
> 'toUpperCase' 를 사용하시겠습니까?

초기값으로 타입을 추론하여 문제점을 찾아주고 있다.

타입시스템의 목표 중 하나는 런타임에 발생될 오류를 미리 찾아내는것이다.  
정적 타입 언어라는 것은 이런 특징을 말하는 것.

여러 문제중 몇가지를 찾아내기도 하는데, 아래 예제를 한번 보자.

```javascript
const customers = [
  { id: 1, age: 13 },
  { id: 2, age: 15 },
  { id: 3, age: 17 },
];

for (const customer of customers) {
  console.log(customer.abe);
}
```

age를 실수로 abe로 입력해 오타가 났을 경우,
자바스크립트에서는 결과가 undefined 3개가 찍혀 나올것이다.  
문법적으로 문제 없으니 유효한 자바스크립트(타입스크립트)이며, 어떠한 오류도 발생하지 않는다.  
이런 경우, 타입스크립트의 타입 체커는 오류를 찾아낸다.

> 'abe' 속성이 ... 형식에 없습니다.  
> 'age' 를 사용하시겠습니까?

타입을 설정하면 더욱 더 많은 오류를 찾아낼 수 있다.

```javascript
const customers = [
  { id: 1, abe: 13 },
  { id: 2, abe: 15 },
  { id: 3, abe: 17 },
];

for (const customer of customers) {
  console.log(customer.age);
}
```

> 'age' 속성이 ... 형식에 없습니다.  
> 'abe' 를 사용하시겠습니까?

어느것이 오타인지 판단하지는 못한다.  
이럴 때, 타입을 추가하면 판단이 가능해 진다.

```typescript
interface Customer {
  id: number;
  age: number;
}

const customers: Customer[] = [
  { id: 1, abe: 13 },
  { id: 2, abe: 15 },
  { id: 3, abe: 17 },
];

for (const customer of customers) {
  console.log(customer.age);
}
```

> 개체 리터럴은 알려진 속성한 지정할 수 있지만  
> 'Customer' 형식에 'abe'가 없습니다.  
> 'age'을(를) 쓰려고 했습니까?

오류가 어디서 발생했는데, 해결책도 올바르게 제시한다.  
타입은 또다른 오류를 찾을 수 있게 해 주는데, 다음 오류를 한번 보자.

```typescript
const customers: Customer[] = [
  { id: 1, age: 13 },
  { id: 2, abe: 15 },
  { id: 3, age: 17 },
];
```

> 'age'을(를) 쓰려고 했습니까?

배열 내부에서의 오타 오류또한 찾아주고 있다.  
만약 타입 구문이 없었다면 아무런 오류없이 실행되었을 것이다.

이 내용을 정리하면, 자바스크립트와 타입스크립트의 superset 구조에서 타입스크립트 내부에 자바스크립트 일부와 교집합이 생기는 새로운 영역을 추가할 수 있다.

타입 체커를 통과한 타입스크립트 프로그램 이라 명명한다.
이 타입 체커는 때때로 정상 동작하는 코드에 오류를 표시하기도 한다.

```typescript
const a = null + 7;
const b = [] + 7;
alert("hello", "typescript");
```

프로그램에 오류가 발생하지 않았더라도, 타입 체커가 오류를 표시할 수 있다는 것이다.  
사용 할 지 안할지는 선택에 달려있지만, 채택한다면 오류가 적은 코드를 작성할 수 있다.
타입 체커가 모든 오류를 표시해주는 것은 아니다.

```typescript
const names = ["Alice", "Bob"];
console.log(names[2].toUpperCase());
```

> TypeError: Cannot read property 'toUpperCase' of undefined

타입스크립트는 배열이 범위 내에서 사용될 것이라 가정해 names[2]가 string 타입일 것으로 예상했지만, 실제로는 undefined이며 런타임시에 오류가 발생했다.

2. 타입스크립트 설정 이해하기

# 2. 타입스크립트 설정 이해하기

다음 코드가 문제 없이 타입 체커를 통과할까?

```ts
function add(a, b) {
  return a + b;
}
add(10, null);
```

정답은 ?

> 설정에 따라 다르다

설정들은 tsconfig.json 을 통해 가능하다.

noImplicityAny와 strictNullChecks 이해를 해 보자.

noImplicityAny가 false면

타입을 지정해주지 않을 시 기본적으로 any 타입을 갖게 되는데 이를 암시적 any라 부른다. any는 강력하지만 타입 체커를 무력화 시키므로 조심해서 사용해야 한다.

noImplicityAny가 true면

타입을 지정해주지 않을 시 오류를 발생시킨다.

명시적으로 any타입을 지정 해 주거나, 분명한 타입을 지정해 주어 해결할 수 있다.

strictNullChecks 는 null과 undefined가 모든 타입에서 허용되는지 여부인데, 다음 코드를 보자.

```ts
const x: number = null; // 또는 undefined
```

strictNullChecks 가 설정되었으면 오류를 출력하고, 설정되어있지 않으면 오류가 없는 유효한 코드가 된다.

```ts
const x: number | null = null;
```

명시적으로 작성 해 주자.

그리고, 이 x를 이렇게 사용하면, nullCheck 코드나 단언문(as 또는 !)을 사용해야 한다.

오류를 찾아내는 데 많은 도움을 주지만, 코드 작성을 어렵게 한다.

# 코드 생성과 타입이 관계없음을 이해하기

ts compiler 는 구버전의 js로 트랜스파일하고, 타입 오류를 체크한다.

두 가지가 독립적인데, js에는 타입 오류라는 개념이 없으므로 트랜스파일이 가능하다.

타입스크립트의 타입 오류는 다른 언어에서의 Warning과 비슷하다.

만약 오류가 있을때 컴파일을 하지 않기를 원하면, noEmitOnError 를 설정하자.

> 런타임에는 타입 체크가 불가능하다.

```ts
interface Square {
  width: number;
}

interface Rectangle extends Shape {
  height: number;
}

type Shape = Square | Rectangle;

function calc(shape: Shape) {
  if (shape instanceof Rectangle) {
    console.log("test");
  }
}
```

instanceof 체크는 런타임에 실시되지만, Rectangle은 타입이기 때문에 컴파일 과정에서 사라지고, 체크가 불가능해 진다.

타입 정보를 기억할 순 없을까?

```ts
function calc(shape: Shape) {
  if ("height" in shape) {
    console.log("test");
  }
}
```

속성을 체크하기.

또 다른 방법으로는 런타임에 접근가능한 타입 정보를 명시적으로 저장하는 방법이 있다.

```ts
interface Square {
  kind: "square";
  width: number;
}

interface Rectangle extends Shape {
  kind: "rectangle";
  height: number;
}

function calc(shape: Shape) {
  if (shape.kind === "rectangle") {
    console.log("test");
  }
}
```

또 다른 방법으로는 클래스화 시키는것이 있다.

클래스화 시키면

```ts
type Shape = Square | Rectangle;
```

위 코드에서는 타입으로 참조되나

```ts
function calc(shape: Shape) {
  if (shape instanceof Rectangle) {
    console.log("test");
  }
}
```

위 코드에서는 값으로 참조된다.
