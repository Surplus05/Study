# 객체 리터럴  

## 객체란 ?  
자바스크립트를 구성하는 값 중 원시값을 제외한 나머지 값은 모두 객체이다.  
객체의 프로퍼티는 key와 value로 구성된다.  
자바스크립트의 모든 값은 프로퍼티의 value가 될 수 있는데, value로 다른 객체나 함수가 올 수 있다.  
함수가 오는 경우에는 메서드라 부른다.  

## 객체 리터럴에 의한 객체 생성  
다른 언어는 흔히 new 연산자 통해 생성자를 호출해 인스턴스를 생성하는 방식으로 객체를 생성한다.  
자바스크립트는 프로토타입 기반 언이로서, 다양한 객체 생성방법을 지원한다.  
* 객체 리터럴
* Object 생성자 함수
* 생성자 함수
* Object.create 메서드
* 클래스 (ES6)

객체 리터럴은 객체를 생성하기 위한 표기법으로, 중괄호를 통해 프로퍼티를 정의한다.  
객체 리터럴의 중괄호는 코드 블록과 생김새가 같음에 유의하자.  
객체 리터럴은 어디까지나 값으로 평가되므로, 세미콜론이 붙는다.  

## 프로퍼티  
객체는 프로터이의 집합이며, 프로퍼티는 키와 값으로 구성된다.  

프로퍼티를 나열할 때는 쉼표로 구분한다.  
프로퍼티 키는 빈 문자열을 포함하는 모든 문자열 또는 심벌 값이 올 수 있다.  
프로퍼티 값은 자바스크립트에서 사용할 수 있는 모든 값이 올 수 있다.  

식별자 네이밍 규칙을 준수하면 따옴표가 필요 없으나, 준수하지 않으면 따옴표가 필요하다.  

```js
let person = {
  lastName: "Kim",
  "last-name" : "Kim",
  last-name : "Kim", // SyntaxError: Unexpected token ~
}
```
-연산자가 있는 표현식으로 해석하기 때문이다.  
대괄호를 통해 키를 동적으로 생성할 수 있다.  
> ES6에서는 이를 계산된 프로퍼티라 하며 객체 리터럴 내부에서도 동적인 키를 사용할 수 있다.
```js
let obj = {};
let key = 'key';

obj[key] = 'value';
console.log(obj);
```

키로 문자열이나 심벌 외에 다른 타입의 값을 사용하면 암묵적으로 문자열로 변환된다.  
예약어의 경우 오류는 없지만 사용하지 말자.  

이미 존재하는 키를 중복 선언하면 나중에 오는 키가 덮어쓰게 된다.  

## 메서드  

프로퍼티의 값이 함수일 경우, 이를 메서드라 부른다.  
```js

let circle = {
  radius:5;
  getDiameter: function () {
    return 2 * this.radius;
  }
```

this는 circle을 가리키는데, 22장 "this"에서 살펴보자.  

## 프로퍼티 접근  
프로퍼티에 접근하는 방법은 두가지가 존재한다.  
* 마침표 표기
* 대괄호 표기
  
```js
let person = {
  birth: '20000101';
}

console.log(person.birth)

console.log(person['birth'])
```

마침표 표기법은 네이밍 규칙을 준수하는 경우만 가능하다.  
person.birth-date 와 같은 예시를 기억하자.  

대괄호 표기법은 반드시 따옴표로 감싸야 한다.  
person[birth] 일때, "birth"가 아니라 birth의 값이 키가 됨을 유의하자. (식별자로 해석한다)  

그리고 존재하지 않는 프로퍼티에 접근하면 undefined를 반환하는데, 이떄 아무런 에러가 없음을 유의하자.  

## 프로퍼티 값 갱신  
이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.  

## 프로퍼티 동적 생성  
존재하지 않는 프로퍼티에 값을 할당하면 새로운 프로퍼티가 동적으로 생성되어 객체에 추가되고, 값이 할당된다.

## 프로퍼티 삭제  

delete 연산자를 통해 삭제가 가능하다.  
```js
delete person.birth;
```
존재하지 않는 프로퍼티를 delete 연산자로 삭제해도 에러가 없음에 유의하자.  

## ES6 이후의 객체 리터럴 확장기능  

* 프로퍼티 축약 표현
  프로퍼티 값으로 변수를 사용할 때, 프로퍼티 키와 변수 이름이 동일하면 생략할 수 있다.

  ```js
  let x = 1, y = 2;

  const obj = {
    x: x,
    y: y,
  }

  const newObj = { x, y };  
  ```
  결과는 동일하다.

  
* 계산된 프로퍼티 이름
  프로퍼티 키로 사용할 표현식을 대괄호로 묶어 프로퍼티 키를 동적으로 생성할 수 있다.

  ES6 이전 버전에서는 객체 리터럴 외부에서만 가능했지만, ES6 부터는 객체 리터럴 내부에서도 사용할 수 있다.

  ```js
  const prefix = 'prop';
  let  i = 0;

  const obj = {
    [`${prefix}-${++i}`] : i,
    [`${prefix}-${++i}`] : i,
    [`${prefix}-${++i}`] : i,
  }
  console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
  ```

* 메서드 축약 표현
  ```js
    const object = {
    sayHi: function() { // ES6 이전 방식
      console.log('hi');
    },
    sayHello() { // ES6 이후 방식
      console.log('hello');
    }
  }
  ```

  두 방버의 동작방식이 다른데, 이는 26.2절에서 살펴보자.
  
